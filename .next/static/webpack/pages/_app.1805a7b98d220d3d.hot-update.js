"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/services/api.ts":
/*!*****************************!*\
  !*** ./src/services/api.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiService: function() { return /* binding */ apiService; }\n/* harmony export */ });\n/* harmony import */ var _config_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/constants */ \"./src/config/constants.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _mockApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mockApi */ \"./src/services/mockApi.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n// Centralized API service for backend communication\n\n\n\nclass ApiService {\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        // Use mock API if configured\n        if (this.useMockApi) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.debug(\"Using mock API service\");\n            return this.delegateToMockApi(endpoint, options);\n        }\n        const url = \"\".concat(this.baseUrl).concat(endpoint);\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), this.timeout);\n        const defaultHeaders = {\n            \"Content-Type\": \"application/json\",\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        };\n        // Add auth token if available\n        const token =  true ? localStorage.getItem(\"authToken\") : 0;\n        if (token) {\n            defaultHeaders[\"Authorization\"] = \"Bearer \".concat(token);\n        }\n        const config = {\n            ...options,\n            headers: {\n                ...defaultHeaders,\n                ...options.headers\n            },\n            signal: controller.signal\n        };\n        try {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.debug(\"API Request: \".concat(options.method || \"GET\", \" \").concat(url));\n            const response = await fetch(url, config);\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n            }\n            const data = await response.json();\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.debug(\"API Response: \".concat(url), data);\n            return data;\n        } catch (error) {\n            clearTimeout(timeoutId);\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.error(\"API Error: \".concat(url), error);\n            if (error.name === \"AbortError\") {\n                throw new Error(_config_constants__WEBPACK_IMPORTED_MODULE_0__.ERROR_MESSAGES.network);\n            }\n            // Fallback to mock API if real API fails\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn(\"Real API failed, falling back to mock API\");\n            this.useMockApi = true;\n            return this.delegateToMockApi(endpoint, options);\n        }\n    }\n    async delegateToMockApi(endpoint, options) {\n        const method = options.method || \"GET\";\n        const body = options.body ? JSON.parse(options.body) : undefined;\n        // Route to appropriate mock API method based on endpoint and method\n        try {\n            if (endpoint === \"/auth/tenant/login\" && method === \"POST\") {\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.login(body.roomNumber, body.aadhaarNumber);\n            }\n            if (endpoint === \"/auth/owner/login\" && method === \"POST\") {\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.loginOwner(body.email, body.password);\n            }\n            if (endpoint === \"/auth/logout\" && method === \"POST\") {\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.logout();\n            }\n            if (endpoint === \"/auth/refresh\" && method === \"POST\") {\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.refreshToken();\n            }\n            if (endpoint.startsWith(\"/tenants/\") && endpoint.endsWith(\"/notifications\")) {\n                const tenantId = endpoint.split(\"/\")[2];\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.getNotifications(tenantId);\n            }\n            if (endpoint.startsWith(\"/tenants/\") && !endpoint.includes(\"/\")) {\n                const tenantId = endpoint.split(\"/\")[2];\n                if (method === \"GET\") {\n                    return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.getTenantProfile(tenantId);\n                }\n                if (method === \"PUT\") {\n                    return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.updateTenantProfile(tenantId, body);\n                }\n            }\n            if (endpoint.startsWith(\"/tenants/\") && endpoint.endsWith(\"/payments\")) {\n                const tenantId = endpoint.split(\"/\")[2];\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.getTenantPayments(tenantId);\n            }\n            if (endpoint.startsWith(\"/tenants/\") && endpoint.endsWith(\"/service-requests\")) {\n                const tenantId = endpoint.split(\"/\")[2];\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.getTenantServiceRequests(tenantId);\n            }\n            if (endpoint === \"/owner/tenants\" && method === \"GET\") {\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.getAllTenants();\n            }\n            if (endpoint === \"/owner/rooms\" && method === \"GET\") {\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.getAllRooms();\n            }\n            if (endpoint === \"/owner/payments\" && method === \"GET\") {\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.getAllPayments();\n            }\n            if (endpoint === \"/owner/service-requests\" && method === \"GET\") {\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.getAllServiceRequests();\n            }\n            if (endpoint === \"/payments\" && method === \"POST\") {\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.submitPayment(body);\n            }\n            if (endpoint === \"/service-requests\" && method === \"POST\") {\n                return await _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.createServiceRequest(body);\n            }\n            // Default fallback\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn(\"No mock implementation for \".concat(method, \" \").concat(endpoint));\n            return {\n                success: true,\n                data: []\n            };\n        } catch (error) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.error(\"Mock API error\", error);\n            return {\n                success: false,\n                error: \"Mock API error\"\n            };\n        }\n    }\n    async retryRequest(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        let lastError;\n        for(let attempt = 1; attempt <= this.retryAttempts; attempt++){\n            try {\n                return await this.request(endpoint, options);\n            } catch (error) {\n                lastError = error;\n                if (attempt < this.retryAttempts) {\n                    _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn(\"API retry attempt \".concat(attempt, \" failed, retrying...\"), error);\n                    await new Promise((resolve)=>setTimeout(resolve, this.retryDelay * attempt));\n                }\n            }\n        }\n        throw lastError;\n    }\n    // Authentication APIs\n    async login(roomNumber, aadhaarNumber) {\n        return this.retryRequest(\"/auth/tenant/login\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                roomNumber,\n                aadhaarNumber\n            })\n        });\n    }\n    async loginOwner(email, password) {\n        return this.retryRequest(\"/auth/owner/login\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                email,\n                password\n            })\n        });\n    }\n    async logout() {\n        return this.retryRequest(\"/auth/logout\", {\n            method: \"POST\"\n        });\n    }\n    async refreshToken() {\n        return this.retryRequest(\"/auth/refresh\", {\n            method: \"POST\"\n        });\n    }\n    // Tenant APIs\n    async getTenantProfile(tenantId) {\n        return this.retryRequest(\"/tenants/\".concat(tenantId));\n    }\n    async updateTenantProfile(tenantId, data) {\n        return this.retryRequest(\"/tenants/\".concat(tenantId), {\n            method: \"PUT\",\n            body: JSON.stringify(data)\n        });\n    }\n    async completeTenantOnboarding(tenantId, data) {\n        return this.retryRequest(\"/tenants/\".concat(tenantId, \"/onboarding\"), {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async uploadTenantDocument(tenantId, file, type) {\n        const formData = new FormData();\n        formData.append(\"file\", file);\n        formData.append(\"type\", type);\n        return this.retryRequest(\"/tenants/\".concat(tenantId, \"/documents\"), {\n            method: \"POST\",\n            body: formData,\n            headers: {}\n        });\n    }\n    // Owner APIs - Full access to all data\n    async getAllTenants() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, filters = arguments.length > 2 ? arguments[2] : void 0;\n        const params = new URLSearchParams({\n            page: page.toString(),\n            limit: limit.toString(),\n            ...filters\n        });\n        return this.retryRequest(\"/owner/tenants?\".concat(params));\n    }\n    async getTenantById(tenantId) {\n        return this.retryRequest(\"/owner/tenants/\".concat(tenantId));\n    }\n    async updateTenantByOwner(tenantId, data) {\n        return this.retryRequest(\"/owner/tenants/\".concat(tenantId), {\n            method: \"PUT\",\n            body: JSON.stringify(data)\n        });\n    }\n    async deleteTenant(tenantId) {\n        return this.retryRequest(\"/owner/tenants/\".concat(tenantId), {\n            method: \"DELETE\"\n        });\n    }\n    // Room Management APIs\n    async getAllRooms() {\n        return this.retryRequest(\"/owner/rooms\");\n    }\n    async getRoomById(roomId) {\n        return this.retryRequest(\"/owner/rooms/\".concat(roomId));\n    }\n    async createRoom(data) {\n        return this.retryRequest(\"/owner/rooms\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async updateRoom(roomId, data) {\n        return this.retryRequest(\"/owner/rooms/\".concat(roomId), {\n            method: \"PUT\",\n            body: JSON.stringify(data)\n        });\n    }\n    async deleteRoom(roomId) {\n        return this.retryRequest(\"/owner/rooms/\".concat(roomId), {\n            method: \"DELETE\"\n        });\n    }\n    async assignTenantToRoom(roomId, tenantId) {\n        return this.retryRequest(\"/owner/rooms/\".concat(roomId, \"/assign\"), {\n            method: \"POST\",\n            body: JSON.stringify({\n                tenantId\n            })\n        });\n    }\n    async removeTenantFromRoom(roomId) {\n        return this.retryRequest(\"/owner/rooms/\".concat(roomId, \"/remove-tenant\"), {\n            method: \"POST\"\n        });\n    }\n    // Payment APIs\n    async submitPayment(data) {\n        return this.retryRequest(\"/payments\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async getTenantPayments(tenantId) {\n        return this.retryRequest(\"/tenants/\".concat(tenantId, \"/payments\"));\n    }\n    async getAllPayments() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, filters = arguments.length > 2 ? arguments[2] : void 0;\n        const params = new URLSearchParams({\n            page: page.toString(),\n            limit: limit.toString(),\n            ...filters\n        });\n        return this.retryRequest(\"/owner/payments?\".concat(params));\n    }\n    async updatePaymentStatus(paymentId, status) {\n        return this.retryRequest(\"/owner/payments/\".concat(paymentId, \"/status\"), {\n            method: \"PUT\",\n            body: JSON.stringify({\n                status\n            })\n        });\n    }\n    async verifyPayment(paymentId, verified) {\n        return this.retryRequest(\"/owner/payments/\".concat(paymentId, \"/verify\"), {\n            method: \"PUT\",\n            body: JSON.stringify({\n                verified\n            })\n        });\n    }\n    // Service Request APIs\n    async createServiceRequest(data) {\n        return this.retryRequest(\"/service-requests\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async getTenantServiceRequests(tenantId) {\n        return this.retryRequest(\"/tenants/\".concat(tenantId, \"/service-requests\"));\n    }\n    async getAllServiceRequests() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, filters = arguments.length > 2 ? arguments[2] : void 0;\n        const params = new URLSearchParams({\n            page: page.toString(),\n            limit: limit.toString(),\n            ...filters\n        });\n        return this.retryRequest(\"/owner/service-requests?\".concat(params));\n    }\n    async updateServiceRequestStatus(requestId, status) {\n        return this.retryRequest(\"/owner/service-requests/\".concat(requestId, \"/status\"), {\n            method: \"PUT\",\n            body: JSON.stringify({\n                status\n            })\n        });\n    }\n    async addServiceRequestNote(requestId, note) {\n        return this.retryRequest(\"/owner/service-requests/\".concat(requestId, \"/notes\"), {\n            method: \"POST\",\n            body: JSON.stringify({\n                note\n            })\n        });\n    }\n    // Notification APIs\n    async getNotifications(userId) {\n        return this.retryRequest(\"/users/\".concat(userId, \"/notifications\"));\n    }\n    async markNotificationAsRead(notificationId) {\n        return this.retryRequest(\"/notifications/\".concat(notificationId, \"/read\"), {\n            method: \"PUT\"\n        });\n    }\n    async markAllNotificationsAsRead(userId) {\n        return this.retryRequest(\"/users/\".concat(userId, \"/notifications/read-all\"), {\n            method: \"PUT\"\n        });\n    }\n    async sendNotification(data) {\n        return this.retryRequest(\"/owner/notifications/send\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async sendBulkNotifications(data) {\n        return this.retryRequest(\"/owner/notifications/send-bulk\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    // Analytics APIs\n    async getDashboardStats() {\n        return this.retryRequest(\"/owner/analytics/dashboard\");\n    }\n    async getRevenueAnalytics(period) {\n        return this.retryRequest(\"/owner/analytics/revenue?period=\".concat(period));\n    }\n    async getOccupancyAnalytics(period) {\n        return this.retryRequest(\"/owner/analytics/occupancy?period=\".concat(period));\n    }\n    async getPaymentAnalytics(period) {\n        return this.retryRequest(\"/owner/analytics/payments?period=\".concat(period));\n    }\n    async exportData(type) {\n        let format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"csv\";\n        return this.retryRequest(\"/owner/export/\".concat(type, \"?format=\").concat(format), {\n            method: \"POST\"\n        });\n    }\n    // File Upload APIs\n    async uploadFile(file, type, metadata) {\n        const formData = new FormData();\n        formData.append(\"file\", file);\n        formData.append(\"type\", type);\n        if (metadata) {\n            formData.append(\"metadata\", JSON.stringify(metadata));\n        }\n        return this.retryRequest(\"/upload\", {\n            method: \"POST\",\n            body: formData,\n            headers: {}\n        });\n    }\n    async deleteFile(fileId) {\n        return this.retryRequest(\"/files/\".concat(fileId), {\n            method: \"DELETE\"\n        });\n    }\n    // Real-time connection APIs\n    async subscribeToUpdates(userId, callback) {\n        if (this.useMockApi) {\n            return _mockApi__WEBPACK_IMPORTED_MODULE_2__.mockApiService.subscribeToUpdates(userId, callback);\n        }\n        // WebSocket connection for real-time updates\n        const wsUrl = this.baseUrl.replace(\"http\", \"ws\") + \"/ws/\".concat(userId);\n        const ws = new WebSocket(wsUrl);\n        ws.onopen = ()=>{\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.info(\"WebSocket connected\");\n        };\n        ws.onmessage = (event)=>{\n            try {\n                const data = JSON.parse(event.data);\n                callback(data);\n            } catch (error) {\n                _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.error(\"WebSocket message parse error\", error);\n            }\n        };\n        ws.onerror = (error)=>{\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.error(\"WebSocket error\", error);\n        };\n        ws.onclose = ()=>{\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.info(\"WebSocket disconnected\");\n        };\n        // Return cleanup function\n        return ()=>{\n            ws.close();\n        };\n    }\n    constructor(){\n        this.baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || \"http://localhost:5000/api\";\n        this.timeout = parseInt(process.env.NEXT_PUBLIC_API_TIMEOUT || \"10000\");\n        this.retryAttempts = 3;\n        this.retryDelay = 1000;\n        // Use mock API if no backend is available or in development mode\n        this.useMockApi =  true || 0;\n    }\n}\nconst apiService = new ApiService();\n/* harmony default export */ __webpack_exports__[\"default\"] = (apiService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ2tDLEtBQUssQ0FBQyxtQkFBbUJBO1FBQ2xDO1FBRUE2RixHQUFHTyxPQUFPLEdBQUc7WUFDWHRJLGlEQUFNQSxDQUFDa0ksSUFBSSxDQUFDO1FBQ2Q7UUFFQSwwQkFBMEI7UUFDMUIsT0FBTztZQUNMSCxHQUFHUSxLQUFLO1FBQ1Y7SUFDRjtJQXpmQUMsYUFBYztRQUNaLElBQUksQ0FBQzlILE9BQU8sR0FBRytILE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0Msd0JBQXdCLElBQUk7UUFDdkQsSUFBSSxDQUFDM0gsT0FBTyxHQUFHNEgsU0FBU0gsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRyx1QkFBdUIsSUFBSTtRQUMvRCxJQUFJLENBQUN2RSxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDRyxVQUFVLEdBQUc7UUFDbEIsaUVBQWlFO1FBQ2pFLElBQUksQ0FBQ25FLFVBQVUsR0FBR21JLEtBQXlCLElBQWlCLENBQXFDO0lBQ25HO0FBbWZGO0FBRU8sTUFBTU0sYUFBYSxJQUFJN0ksYUFBYTtBQUMzQywrREFBZTZJLFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL2FwaS50cz85NTZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENlbnRyYWxpemVkIEFQSSBzZXJ2aWNlIGZvciBiYWNrZW5kIGNvbW11bmljYXRpb25cbmltcG9ydCB7IEFQUF9DT05GSUcsIEVSUk9SX01FU1NBR0VTIH0gZnJvbSAnLi4vY29uZmlnL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgbW9ja0FwaVNlcnZpY2UgfSBmcm9tICcuL21vY2tBcGknO1xuaW1wb3J0IHsgXG4gIFVzZXIsIFxuICBUZW5hbnRQcm9maWxlLCBcbiAgUm9vbSwgXG4gIFBheW1lbnQsIFxuICBTZXJ2aWNlUmVxdWVzdCwgXG4gIE5vdGlmaWNhdGlvbiBcbn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbnRlcmZhY2UgQXBpUmVzcG9uc2U8VD4ge1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBkYXRhPzogVDtcbiAgZXJyb3I/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBQYWdpbmF0ZWRSZXNwb25zZTxUPiB7XG4gIGRhdGE6IFRbXTtcbiAgdG90YWw6IG51bWJlcjtcbiAgcGFnZTogbnVtYmVyO1xuICBsaW1pdDogbnVtYmVyO1xuICBoYXNNb3JlOiBib29sZWFuO1xufVxuXG5jbGFzcyBBcGlTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBiYXNlVXJsOiBzdHJpbmc7XG4gIHByaXZhdGUgdGltZW91dDogbnVtYmVyO1xuICBwcml2YXRlIHJldHJ5QXR0ZW1wdHM6IG51bWJlcjtcbiAgcHJpdmF0ZSByZXRyeURlbGF5OiBudW1iZXI7XG4gIHByaXZhdGUgdXNlTW9ja0FwaTogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfQkFTRV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9hcGknO1xuICAgIHRoaXMudGltZW91dCA9IHBhcnNlSW50KHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9USU1FT1VUIHx8ICcxMDAwMCcpO1xuICAgIHRoaXMucmV0cnlBdHRlbXB0cyA9IDM7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gMTAwMDtcbiAgICAvLyBVc2UgbW9jayBBUEkgaWYgbm8gYmFja2VuZCBpcyBhdmFpbGFibGUgb3IgaW4gZGV2ZWxvcG1lbnQgbW9kZVxuICAgIHRoaXMudXNlTW9ja0FwaSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnIHx8ICFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfQkFTRV9VUkw7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlcXVlc3Q8VD4oXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgICBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9XG4gICk6IFByb21pc2U8QXBpUmVzcG9uc2U8VD4+IHtcbiAgICAvLyBVc2UgbW9jayBBUEkgaWYgY29uZmlndXJlZFxuICAgIGlmICh0aGlzLnVzZU1vY2tBcGkpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnVXNpbmcgbW9jayBBUEkgc2VydmljZScpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGVUb01vY2tBcGkoZW5kcG9pbnQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0ke2VuZHBvaW50fWA7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGhpcy50aW1lb3V0KTtcblxuICAgIGNvbnN0IGRlZmF1bHRIZWFkZXJzID0ge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyxcbiAgICB9O1xuXG4gICAgLy8gQWRkIGF1dGggdG9rZW4gaWYgYXZhaWxhYmxlXG4gICAgY29uc3QgdG9rZW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKSA6IG51bGw7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBkZWZhdWx0SGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlnOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLmRlZmF1bHRIZWFkZXJzLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgQVBJIFJlcXVlc3Q6ICR7b3B0aW9ucy5tZXRob2QgfHwgJ0dFVCd9ICR7dXJsfWApO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgY29uZmlnKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgQVBJIFJlc3BvbnNlOiAke3VybH1gLCBkYXRhKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgbG9nZ2VyLmVycm9yKGBBUEkgRXJyb3I6ICR7dXJsfWAsIGVycm9yKTtcbiAgICAgIFxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTUVTU0FHRVMubmV0d29yayk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZhbGxiYWNrIHRvIG1vY2sgQVBJIGlmIHJlYWwgQVBJIGZhaWxzXG4gICAgICBsb2dnZXIud2FybignUmVhbCBBUEkgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gbW9jayBBUEknKTtcbiAgICAgIHRoaXMudXNlTW9ja0FwaSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZVRvTW9ja0FwaShlbmRwb2ludCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBkZWxlZ2F0ZVRvTW9ja0FwaTxUPihlbmRwb2ludDogc3RyaW5nLCBvcHRpb25zOiBSZXF1ZXN0SW5pdCk6IFByb21pc2U8QXBpUmVzcG9uc2U8VD4+IHtcbiAgICBjb25zdCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJztcbiAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5ID8gSlNPTi5wYXJzZShvcHRpb25zLmJvZHkgYXMgc3RyaW5nKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIFJvdXRlIHRvIGFwcHJvcHJpYXRlIG1vY2sgQVBJIG1ldGhvZCBiYXNlZCBvbiBlbmRwb2ludCBhbmQgbWV0aG9kXG4gICAgdHJ5IHtcbiAgICAgIGlmIChlbmRwb2ludCA9PT0gJy9hdXRoL3RlbmFudC9sb2dpbicgJiYgbWV0aG9kID09PSAnUE9TVCcpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG1vY2tBcGlTZXJ2aWNlLmxvZ2luKGJvZHkucm9vbU51bWJlciwgYm9keS5hYWRoYWFyTnVtYmVyKSBhcyBBcGlSZXNwb25zZTxUPjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGVuZHBvaW50ID09PSAnL2F1dGgvb3duZXIvbG9naW4nICYmIG1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBtb2NrQXBpU2VydmljZS5sb2dpbk93bmVyKGJvZHkuZW1haWwsIGJvZHkucGFzc3dvcmQpIGFzIEFwaVJlc3BvbnNlPFQ+O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZW5kcG9pbnQgPT09ICcvYXV0aC9sb2dvdXQnICYmIG1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBtb2NrQXBpU2VydmljZS5sb2dvdXQoKSBhcyBBcGlSZXNwb25zZTxUPjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGVuZHBvaW50ID09PSAnL2F1dGgvcmVmcmVzaCcgJiYgbWV0aG9kID09PSAnUE9TVCcpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG1vY2tBcGlTZXJ2aWNlLnJlZnJlc2hUb2tlbigpIGFzIEFwaVJlc3BvbnNlPFQ+O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZW5kcG9pbnQuc3RhcnRzV2l0aCgnL3RlbmFudHMvJykgJiYgZW5kcG9pbnQuZW5kc1dpdGgoJy9ub3RpZmljYXRpb25zJykpIHtcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSBlbmRwb2ludC5zcGxpdCgnLycpWzJdO1xuICAgICAgICByZXR1cm4gYXdhaXQgbW9ja0FwaVNlcnZpY2UuZ2V0Tm90aWZpY2F0aW9ucyh0ZW5hbnRJZCkgYXMgQXBpUmVzcG9uc2U8VD47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChlbmRwb2ludC5zdGFydHNXaXRoKCcvdGVuYW50cy8nKSAmJiAhZW5kcG9pbnQuaW5jbHVkZXMoJy8nKSkge1xuICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGVuZHBvaW50LnNwbGl0KCcvJylbMl07XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IG1vY2tBcGlTZXJ2aWNlLmdldFRlbmFudFByb2ZpbGUodGVuYW50SWQpIGFzIEFwaVJlc3BvbnNlPFQ+O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdQVVQnKSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IG1vY2tBcGlTZXJ2aWNlLnVwZGF0ZVRlbmFudFByb2ZpbGUodGVuYW50SWQsIGJvZHkpIGFzIEFwaVJlc3BvbnNlPFQ+O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChlbmRwb2ludC5zdGFydHNXaXRoKCcvdGVuYW50cy8nKSAmJiBlbmRwb2ludC5lbmRzV2l0aCgnL3BheW1lbnRzJykpIHtcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSBlbmRwb2ludC5zcGxpdCgnLycpWzJdO1xuICAgICAgICByZXR1cm4gYXdhaXQgbW9ja0FwaVNlcnZpY2UuZ2V0VGVuYW50UGF5bWVudHModGVuYW50SWQpIGFzIEFwaVJlc3BvbnNlPFQ+O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZW5kcG9pbnQuc3RhcnRzV2l0aCgnL3RlbmFudHMvJykgJiYgZW5kcG9pbnQuZW5kc1dpdGgoJy9zZXJ2aWNlLXJlcXVlc3RzJykpIHtcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSBlbmRwb2ludC5zcGxpdCgnLycpWzJdO1xuICAgICAgICByZXR1cm4gYXdhaXQgbW9ja0FwaVNlcnZpY2UuZ2V0VGVuYW50U2VydmljZVJlcXVlc3RzKHRlbmFudElkKSBhcyBBcGlSZXNwb25zZTxUPjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGVuZHBvaW50ID09PSAnL293bmVyL3RlbmFudHMnICYmIG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG1vY2tBcGlTZXJ2aWNlLmdldEFsbFRlbmFudHMoKSBhcyBBcGlSZXNwb25zZTxUPjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGVuZHBvaW50ID09PSAnL293bmVyL3Jvb21zJyAmJiBtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBtb2NrQXBpU2VydmljZS5nZXRBbGxSb29tcygpIGFzIEFwaVJlc3BvbnNlPFQ+O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZW5kcG9pbnQgPT09ICcvb3duZXIvcGF5bWVudHMnICYmIG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG1vY2tBcGlTZXJ2aWNlLmdldEFsbFBheW1lbnRzKCkgYXMgQXBpUmVzcG9uc2U8VD47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChlbmRwb2ludCA9PT0gJy9vd25lci9zZXJ2aWNlLXJlcXVlc3RzJyAmJiBtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBtb2NrQXBpU2VydmljZS5nZXRBbGxTZXJ2aWNlUmVxdWVzdHMoKSBhcyBBcGlSZXNwb25zZTxUPjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGVuZHBvaW50ID09PSAnL3BheW1lbnRzJyAmJiBtZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgICByZXR1cm4gYXdhaXQgbW9ja0FwaVNlcnZpY2Uuc3VibWl0UGF5bWVudChib2R5KSBhcyBBcGlSZXNwb25zZTxUPjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGVuZHBvaW50ID09PSAnL3NlcnZpY2UtcmVxdWVzdHMnICYmIG1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBtb2NrQXBpU2VydmljZS5jcmVhdGVTZXJ2aWNlUmVxdWVzdChib2R5KSBhcyBBcGlSZXNwb25zZTxUPjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGVmYXVsdCBmYWxsYmFja1xuICAgICAgbG9nZ2VyLndhcm4oYE5vIG1vY2sgaW1wbGVtZW50YXRpb24gZm9yICR7bWV0aG9kfSAke2VuZHBvaW50fWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogW10gYXMgYW55XG4gICAgICB9IGFzIEFwaVJlc3BvbnNlPFQ+O1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignTW9jayBBUEkgZXJyb3InLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdNb2NrIEFQSSBlcnJvcidcbiAgICAgIH0gYXMgQXBpUmVzcG9uc2U8VD47XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZXRyeVJlcXVlc3Q8VD4oXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgICBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9XG4gICk6IFByb21pc2U8QXBpUmVzcG9uc2U8VD4+IHtcbiAgICBsZXQgbGFzdEVycm9yOiBFcnJvcjtcblxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IHRoaXMucmV0cnlBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0PFQ+KGVuZHBvaW50LCBvcHRpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxhc3RFcnJvciA9IGVycm9yIGFzIEVycm9yO1xuICAgICAgICBcbiAgICAgICAgaWYgKGF0dGVtcHQgPCB0aGlzLnJldHJ5QXR0ZW1wdHMpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgQVBJIHJldHJ5IGF0dGVtcHQgJHthdHRlbXB0fSBmYWlsZWQsIHJldHJ5aW5nLi4uYCwgZXJyb3IpO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLnJldHJ5RGVsYXkgKiBhdHRlbXB0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBsYXN0RXJyb3IhO1xuICB9XG5cbiAgLy8gQXV0aGVudGljYXRpb24gQVBJc1xuICBhc3luYyBsb2dpbihyb29tTnVtYmVyOiBzdHJpbmcsIGFhZGhhYXJOdW1iZXI6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8VXNlcj4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoJy9hdXRoL3RlbmFudC9sb2dpbicsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyByb29tTnVtYmVyLCBhYWRoYWFyTnVtYmVyIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgbG9naW5Pd25lcihlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxVc2VyPj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdCgnL2F1dGgvb3duZXIvbG9naW4nLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIHBhc3N3b3JkIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgbG9nb3V0KCk6IFByb21pc2U8QXBpUmVzcG9uc2U8dm9pZD4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoJy9hdXRoL2xvZ291dCcsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVmcmVzaFRva2VuKCk6IFByb21pc2U8QXBpUmVzcG9uc2U8eyB0b2tlbjogc3RyaW5nIH0+PiB7XG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KCcvYXV0aC9yZWZyZXNoJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgfSk7XG4gIH1cblxuICAvLyBUZW5hbnQgQVBJc1xuICBhc3luYyBnZXRUZW5hbnRQcm9maWxlKHRlbmFudElkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFRlbmFudFByb2ZpbGU+PiB7XG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KGAvdGVuYW50cy8ke3RlbmFudElkfWApO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlVGVuYW50UHJvZmlsZSh0ZW5hbnRJZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPFRlbmFudFByb2ZpbGU+KTogUHJvbWlzZTxBcGlSZXNwb25zZTxUZW5hbnRQcm9maWxlPj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChgL3RlbmFudHMvJHt0ZW5hbnRJZH1gLCB7XG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBjb21wbGV0ZVRlbmFudE9uYm9hcmRpbmcodGVuYW50SWQ6IHN0cmluZywgZGF0YTogYW55KTogUHJvbWlzZTxBcGlSZXNwb25zZTxUZW5hbnRQcm9maWxlPj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChgL3RlbmFudHMvJHt0ZW5hbnRJZH0vb25ib2FyZGluZ2AsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyB1cGxvYWRUZW5hbnREb2N1bWVudCh0ZW5hbnRJZDogc3RyaW5nLCBmaWxlOiBGaWxlLCB0eXBlOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHsgdXJsOiBzdHJpbmcgfT4+IHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgndHlwZScsIHR5cGUpO1xuXG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KGAvdGVuYW50cy8ke3RlbmFudElkfS9kb2N1bWVudHNgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgaGVhZGVyczoge30sIC8vIExldCBicm93c2VyIHNldCBDb250ZW50LVR5cGUgZm9yIEZvcm1EYXRhXG4gICAgfSk7XG4gIH1cblxuICAvLyBPd25lciBBUElzIC0gRnVsbCBhY2Nlc3MgdG8gYWxsIGRhdGFcbiAgYXN5bmMgZ2V0QWxsVGVuYW50cyhwYWdlID0gMSwgbGltaXQgPSAyMCwgZmlsdGVycz86IGFueSk6IFByb21pc2U8QXBpUmVzcG9uc2U8UGFnaW5hdGVkUmVzcG9uc2U8VGVuYW50UHJvZmlsZT4+PiB7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICBwYWdlOiBwYWdlLnRvU3RyaW5nKCksXG4gICAgICBsaW1pdDogbGltaXQudG9TdHJpbmcoKSxcbiAgICAgIC4uLmZpbHRlcnMsXG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KGAvb3duZXIvdGVuYW50cz8ke3BhcmFtc31gKTtcbiAgfVxuXG4gIGFzeW5jIGdldFRlbmFudEJ5SWQodGVuYW50SWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8VGVuYW50UHJvZmlsZT4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoYC9vd25lci90ZW5hbnRzLyR7dGVuYW50SWR9YCk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVUZW5hbnRCeU93bmVyKHRlbmFudElkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8VGVuYW50UHJvZmlsZT4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPFRlbmFudFByb2ZpbGU+PiB7XG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KGAvb3duZXIvdGVuYW50cy8ke3RlbmFudElkfWAsIHtcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVRlbmFudCh0ZW5hbnRJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTx2b2lkPj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChgL293bmVyL3RlbmFudHMvJHt0ZW5hbnRJZH1gLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gUm9vbSBNYW5hZ2VtZW50IEFQSXNcbiAgYXN5bmMgZ2V0QWxsUm9vbXMoKTogUHJvbWlzZTxBcGlSZXNwb25zZTxSb29tW10+PiB7XG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KCcvb3duZXIvcm9vbXMnKTtcbiAgfVxuXG4gIGFzeW5jIGdldFJvb21CeUlkKHJvb21JZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxSb29tPj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChgL293bmVyL3Jvb21zLyR7cm9vbUlkfWApO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlUm9vbShkYXRhOiBPbWl0PFJvb20sICdpZCc+KTogUHJvbWlzZTxBcGlSZXNwb25zZTxSb29tPj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdCgnL293bmVyL3Jvb21zJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVJvb20ocm9vbUlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8Um9vbT4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPFJvb20+PiB7XG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KGAvb3duZXIvcm9vbXMvJHtyb29tSWR9YCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlUm9vbShyb29tSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8dm9pZD4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoYC9vd25lci9yb29tcy8ke3Jvb21JZH1gLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgYXNzaWduVGVuYW50VG9Sb29tKHJvb21JZDogc3RyaW5nLCB0ZW5hbnRJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxSb29tPj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChgL293bmVyL3Jvb21zLyR7cm9vbUlkfS9hc3NpZ25gLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdGVuYW50SWQgfSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZW1vdmVUZW5hbnRGcm9tUm9vbShyb29tSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8Um9vbT4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoYC9vd25lci9yb29tcy8ke3Jvb21JZH0vcmVtb3ZlLXRlbmFudGAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gUGF5bWVudCBBUElzXG4gIGFzeW5jIHN1Ym1pdFBheW1lbnQoZGF0YTogT21pdDxQYXltZW50LCAnaWQnPik6IFByb21pc2U8QXBpUmVzcG9uc2U8UGF5bWVudD4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoJy9wYXltZW50cycsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBnZXRUZW5hbnRQYXltZW50cyh0ZW5hbnRJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxQYXltZW50W10+PiB7XG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KGAvdGVuYW50cy8ke3RlbmFudElkfS9wYXltZW50c2ApO1xuICB9XG5cbiAgYXN5bmMgZ2V0QWxsUGF5bWVudHMocGFnZSA9IDEsIGxpbWl0ID0gMjAsIGZpbHRlcnM/OiBhbnkpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFBhZ2luYXRlZFJlc3BvbnNlPFBheW1lbnQ+Pj4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgcGFnZTogcGFnZS50b1N0cmluZygpLFxuICAgICAgbGltaXQ6IGxpbWl0LnRvU3RyaW5nKCksXG4gICAgICAuLi5maWx0ZXJzLFxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChgL293bmVyL3BheW1lbnRzPyR7cGFyYW1zfWApO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlUGF5bWVudFN0YXR1cyhwYXltZW50SWQ6IHN0cmluZywgc3RhdHVzOiBQYXltZW50WydzdGF0dXMnXSk6IFByb21pc2U8QXBpUmVzcG9uc2U8UGF5bWVudD4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoYC9vd25lci9wYXltZW50cy8ke3BheW1lbnRJZH0vc3RhdHVzYCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc3RhdHVzIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5UGF5bWVudChwYXltZW50SWQ6IHN0cmluZywgdmVyaWZpZWQ6IGJvb2xlYW4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPFBheW1lbnQ+PiB7XG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KGAvb3duZXIvcGF5bWVudHMvJHtwYXltZW50SWR9L3ZlcmlmeWAsIHtcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHZlcmlmaWVkIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gU2VydmljZSBSZXF1ZXN0IEFQSXNcbiAgYXN5bmMgY3JlYXRlU2VydmljZVJlcXVlc3QoZGF0YTogT21pdDxTZXJ2aWNlUmVxdWVzdCwgJ2lkJz4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPFNlcnZpY2VSZXF1ZXN0Pj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdCgnL3NlcnZpY2UtcmVxdWVzdHMnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0VGVuYW50U2VydmljZVJlcXVlc3RzKHRlbmFudElkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFNlcnZpY2VSZXF1ZXN0W10+PiB7XG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KGAvdGVuYW50cy8ke3RlbmFudElkfS9zZXJ2aWNlLXJlcXVlc3RzYCk7XG4gIH1cblxuICBhc3luYyBnZXRBbGxTZXJ2aWNlUmVxdWVzdHMocGFnZSA9IDEsIGxpbWl0ID0gMjAsIGZpbHRlcnM/OiBhbnkpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFBhZ2luYXRlZFJlc3BvbnNlPFNlcnZpY2VSZXF1ZXN0Pj4+IHtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgIHBhZ2U6IHBhZ2UudG9TdHJpbmcoKSxcbiAgICAgIGxpbWl0OiBsaW1pdC50b1N0cmluZygpLFxuICAgICAgLi4uZmlsdGVycyxcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoYC9vd25lci9zZXJ2aWNlLXJlcXVlc3RzPyR7cGFyYW1zfWApO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlU2VydmljZVJlcXVlc3RTdGF0dXMocmVxdWVzdElkOiBzdHJpbmcsIHN0YXR1czogU2VydmljZVJlcXVlc3RbJ3N0YXR1cyddKTogUHJvbWlzZTxBcGlSZXNwb25zZTxTZXJ2aWNlUmVxdWVzdD4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoYC9vd25lci9zZXJ2aWNlLXJlcXVlc3RzLyR7cmVxdWVzdElkfS9zdGF0dXNgLCB7XG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzdGF0dXMgfSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBhZGRTZXJ2aWNlUmVxdWVzdE5vdGUocmVxdWVzdElkOiBzdHJpbmcsIG5vdGU6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8U2VydmljZVJlcXVlc3Q+PiB7XG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KGAvb3duZXIvc2VydmljZS1yZXF1ZXN0cy8ke3JlcXVlc3RJZH0vbm90ZXNgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbm90ZSB9KSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE5vdGlmaWNhdGlvbiBBUElzXG4gIGFzeW5jIGdldE5vdGlmaWNhdGlvbnModXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPE5vdGlmaWNhdGlvbltdPj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChgL3VzZXJzLyR7dXNlcklkfS9ub3RpZmljYXRpb25zYCk7XG4gIH1cblxuICBhc3luYyBtYXJrTm90aWZpY2F0aW9uQXNSZWFkKG5vdGlmaWNhdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHZvaWQ+PiB7XG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KGAvbm90aWZpY2F0aW9ucy8ke25vdGlmaWNhdGlvbklkfS9yZWFkYCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIG1hcmtBbGxOb3RpZmljYXRpb25zQXNSZWFkKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTx2b2lkPj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChgL3VzZXJzLyR7dXNlcklkfS9ub3RpZmljYXRpb25zL3JlYWQtYWxsYCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmROb3RpZmljYXRpb24oZGF0YToge1xuICAgIHVzZXJJZDogc3RyaW5nO1xuICAgIHR5cGU6IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICBhY3Rpb25Vcmw/OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPEFwaVJlc3BvbnNlPE5vdGlmaWNhdGlvbj4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoJy9vd25lci9ub3RpZmljYXRpb25zL3NlbmQnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2VuZEJ1bGtOb3RpZmljYXRpb25zKGRhdGE6IHtcbiAgICB1c2VySWRzOiBzdHJpbmdbXTtcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgYWN0aW9uVXJsPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxBcGlSZXNwb25zZTx2b2lkPj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdCgnL293bmVyL25vdGlmaWNhdGlvbnMvc2VuZC1idWxrJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFuYWx5dGljcyBBUElzXG4gIGFzeW5jIGdldERhc2hib2FyZFN0YXRzKCk6IFByb21pc2U8QXBpUmVzcG9uc2U8YW55Pj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdCgnL293bmVyL2FuYWx5dGljcy9kYXNoYm9hcmQnKTtcbiAgfVxuXG4gIGFzeW5jIGdldFJldmVudWVBbmFseXRpY3MocGVyaW9kOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPGFueT4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoYC9vd25lci9hbmFseXRpY3MvcmV2ZW51ZT9wZXJpb2Q9JHtwZXJpb2R9YCk7XG4gIH1cblxuICBhc3luYyBnZXRPY2N1cGFuY3lBbmFseXRpY3MocGVyaW9kOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPGFueT4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoYC9vd25lci9hbmFseXRpY3Mvb2NjdXBhbmN5P3BlcmlvZD0ke3BlcmlvZH1gKTtcbiAgfVxuXG4gIGFzeW5jIGdldFBheW1lbnRBbmFseXRpY3MocGVyaW9kOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPGFueT4+IHtcbiAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QoYC9vd25lci9hbmFseXRpY3MvcGF5bWVudHM/cGVyaW9kPSR7cGVyaW9kfWApO1xuICB9XG5cbiAgYXN5bmMgZXhwb3J0RGF0YSh0eXBlOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nID0gJ2NzdicpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHsgZG93bmxvYWRVcmw6IHN0cmluZyB9Pj4ge1xuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChgL293bmVyL2V4cG9ydC8ke3R5cGV9P2Zvcm1hdD0ke2Zvcm1hdH1gLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZpbGUgVXBsb2FkIEFQSXNcbiAgYXN5bmMgdXBsb2FkRmlsZShmaWxlOiBGaWxlLCB0eXBlOiBzdHJpbmcsIG1ldGFkYXRhPzogYW55KTogUHJvbWlzZTxBcGlSZXNwb25zZTx7IHVybDogc3RyaW5nOyBpZDogc3RyaW5nIH0+PiB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3R5cGUnLCB0eXBlKTtcbiAgICBcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnbWV0YWRhdGEnLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdCgnL3VwbG9hZCcsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICBoZWFkZXJzOiB7fSwgLy8gTGV0IGJyb3dzZXIgc2V0IENvbnRlbnQtVHlwZSBmb3IgRm9ybURhdGFcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZUZpbGUoZmlsZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHZvaWQ+PiB7XG4gICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KGAvZmlsZXMvJHtmaWxlSWR9YCwge1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJlYWwtdGltZSBjb25uZWN0aW9uIEFQSXNcbiAgYXN5bmMgc3Vic2NyaWJlVG9VcGRhdGVzKHVzZXJJZDogc3RyaW5nLCBjYWxsYmFjazogKGRhdGE6IGFueSkgPT4gdm9pZCk6IFByb21pc2U8KCkgPT4gdm9pZD4ge1xuICAgIGlmICh0aGlzLnVzZU1vY2tBcGkpIHtcbiAgICAgIHJldHVybiBtb2NrQXBpU2VydmljZS5zdWJzY3JpYmVUb1VwZGF0ZXModXNlcklkLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHJlYWwtdGltZSB1cGRhdGVzXG4gICAgY29uc3Qgd3NVcmwgPSB0aGlzLmJhc2VVcmwucmVwbGFjZSgnaHR0cCcsICd3cycpICsgYC93cy8ke3VzZXJJZH1gO1xuICAgIGNvbnN0IHdzID0gbmV3IFdlYlNvY2tldCh3c1VybCk7XG5cbiAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICBsb2dnZXIuaW5mbygnV2ViU29ja2V0IGNvbm5lY3RlZCcpO1xuICAgIH07XG5cbiAgICB3cy5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignV2ViU29ja2V0IG1lc3NhZ2UgcGFyc2UgZXJyb3InLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdzLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIGxvZ2dlci5lcnJvcignV2ViU29ja2V0IGVycm9yJywgZXJyb3IpO1xuICAgIH07XG5cbiAgICB3cy5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oJ1dlYlNvY2tldCBkaXNjb25uZWN0ZWQnKTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIGNsZWFudXAgZnVuY3Rpb25cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBhcGlTZXJ2aWNlID0gbmV3IEFwaVNlcnZpY2UoKTtcbmV4cG9ydCBkZWZhdWx0IGFwaVNlcnZpY2U7Il0sIm5hbWVzIjpbIkVSUk9SX01FU1NBR0VTIiwibG9nZ2VyIiwibW9ja0FwaVNlcnZpY2UiLCJBcGlTZXJ2aWNlIiwicmVxdWVzdCIsImVuZHBvaW50Iiwib3B0aW9ucyIsInVzZU1vY2tBcGkiLCJkZWJ1ZyIsImRlbGVnYXRlVG9Nb2NrQXBpIiwidXJsIiwiYmFzZVVybCIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJ0aW1lb3V0IiwiZGVmYXVsdEhlYWRlcnMiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJjb25maWciLCJoZWFkZXJzIiwic2lnbmFsIiwibWV0aG9kIiwicmVzcG9uc2UiLCJmZXRjaCIsImNsZWFyVGltZW91dCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImpzb24iLCJlcnJvciIsIm5hbWUiLCJuZXR3b3JrIiwid2FybiIsImJvZHkiLCJKU09OIiwicGFyc2UiLCJ1bmRlZmluZWQiLCJsb2dpbiIsInJvb21OdW1iZXIiLCJhYWRoYWFyTnVtYmVyIiwibG9naW5Pd25lciIsImVtYWlsIiwicGFzc3dvcmQiLCJsb2dvdXQiLCJyZWZyZXNoVG9rZW4iLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJ0ZW5hbnRJZCIsInNwbGl0IiwiZ2V0Tm90aWZpY2F0aW9ucyIsImluY2x1ZGVzIiwiZ2V0VGVuYW50UHJvZmlsZSIsInVwZGF0ZVRlbmFudFByb2ZpbGUiLCJnZXRUZW5hbnRQYXltZW50cyIsImdldFRlbmFudFNlcnZpY2VSZXF1ZXN0cyIsImdldEFsbFRlbmFudHMiLCJnZXRBbGxSb29tcyIsImdldEFsbFBheW1lbnRzIiwiZ2V0QWxsU2VydmljZVJlcXVlc3RzIiwic3VibWl0UGF5bWVudCIsImNyZWF0ZVNlcnZpY2VSZXF1ZXN0Iiwic3VjY2VzcyIsInJldHJ5UmVxdWVzdCIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJyZXRyeUF0dGVtcHRzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXRyeURlbGF5Iiwic3RyaW5naWZ5IiwiY29tcGxldGVUZW5hbnRPbmJvYXJkaW5nIiwidXBsb2FkVGVuYW50RG9jdW1lbnQiLCJmaWxlIiwidHlwZSIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJwYWdlIiwibGltaXQiLCJmaWx0ZXJzIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJnZXRUZW5hbnRCeUlkIiwidXBkYXRlVGVuYW50QnlPd25lciIsImRlbGV0ZVRlbmFudCIsImdldFJvb21CeUlkIiwicm9vbUlkIiwiY3JlYXRlUm9vbSIsInVwZGF0ZVJvb20iLCJkZWxldGVSb29tIiwiYXNzaWduVGVuYW50VG9Sb29tIiwicmVtb3ZlVGVuYW50RnJvbVJvb20iLCJ1cGRhdGVQYXltZW50U3RhdHVzIiwicGF5bWVudElkIiwidmVyaWZ5UGF5bWVudCIsInZlcmlmaWVkIiwidXBkYXRlU2VydmljZVJlcXVlc3RTdGF0dXMiLCJyZXF1ZXN0SWQiLCJhZGRTZXJ2aWNlUmVxdWVzdE5vdGUiLCJub3RlIiwidXNlcklkIiwibWFya05vdGlmaWNhdGlvbkFzUmVhZCIsIm5vdGlmaWNhdGlvbklkIiwibWFya0FsbE5vdGlmaWNhdGlvbnNBc1JlYWQiLCJzZW5kTm90aWZpY2F0aW9uIiwic2VuZEJ1bGtOb3RpZmljYXRpb25zIiwiZ2V0RGFzaGJvYXJkU3RhdHMiLCJnZXRSZXZlbnVlQW5hbHl0aWNzIiwicGVyaW9kIiwiZ2V0T2NjdXBhbmN5QW5hbHl0aWNzIiwiZ2V0UGF5bWVudEFuYWx5dGljcyIsImV4cG9ydERhdGEiLCJmb3JtYXQiLCJ1cGxvYWRGaWxlIiwibWV0YWRhdGEiLCJkZWxldGVGaWxlIiwiZmlsZUlkIiwic3Vic2NyaWJlVG9VcGRhdGVzIiwiY2FsbGJhY2siLCJ3c1VybCIsInJlcGxhY2UiLCJ3cyIsIldlYlNvY2tldCIsIm9ub3BlbiIsImluZm8iLCJvbm1lc3NhZ2UiLCJldmVudCIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiY2xvc2UiLCJjb25zdHJ1Y3RvciIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfQkFTRV9VUkwiLCJwYXJzZUludCIsIk5FWFRfUFVCTElDX0FQSV9USU1FT1VUIiwiTk9ERV9FTlYiLCJhcGlTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/services/api.ts\n"));

/***/ }),

/***/ "./src/services/mockApi.ts":
/*!*********************************!*\
  !*** ./src/services/mockApi.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mockApiService: function() { return /* binding */ mockApiService; }\n/* harmony export */ });\n// Mock API service to simulate backend responses\n// Mock data\nconst mockTenants = [\n    {\n        uid: \"tenant-101\",\n        roomNumber: \"101\",\n        name: \"John Doe\",\n        email: \"john@example.com\",\n        phone: \"+91 9876543210\",\n        aadhaarNumber: \"1234-5678-9012\",\n        emergencyContact: {\n            name: \"Jane Doe\",\n            phone: \"+91 9876543211\",\n            relation: \"Sister\"\n        },\n        documents: {\n            aadhaar: \"https://example.com/aadhaar.pdf\",\n            photo: \"https://example.com/photo.jpg\"\n        },\n        isOnboardingComplete: true,\n        createdAt: \"2024-01-15T10:00:00Z\",\n        updatedAt: \"2024-01-15T10:00:00Z\"\n    },\n    {\n        uid: \"tenant-102\",\n        roomNumber: \"102\",\n        name: \"Alice Smith\",\n        email: \"alice@example.com\",\n        phone: \"+91 9876543212\",\n        aadhaarNumber: \"2345-6789-0123\",\n        emergencyContact: {\n            name: \"Bob Smith\",\n            phone: \"+91 9876543213\",\n            relation: \"Husband\"\n        },\n        documents: {\n            aadhaar: \"https://example.com/aadhaar2.pdf\",\n            photo: \"https://example.com/photo2.jpg\"\n        },\n        isOnboardingComplete: true,\n        createdAt: \"2024-01-16T10:00:00Z\",\n        updatedAt: \"2024-01-16T10:00:00Z\"\n    }\n];\nconst mockRooms = [\n    {\n        id: \"room-101\",\n        roomNumber: \"101\",\n        floor: 1,\n        type: \"single\",\n        rent: 8000,\n        deposit: 16000,\n        amenities: [\n            \"AC\",\n            \"WiFi\",\n            \"Attached Bathroom\"\n        ],\n        isOccupied: true,\n        tenantId: \"tenant-101\",\n        createdAt: \"2024-01-01T00:00:00Z\",\n        updatedAt: \"2024-01-15T10:00:00Z\"\n    },\n    {\n        id: \"room-102\",\n        roomNumber: \"102\",\n        floor: 1,\n        type: \"single\",\n        rent: 8500,\n        deposit: 17000,\n        amenities: [\n            \"AC\",\n            \"WiFi\",\n            \"Attached Bathroom\",\n            \"Balcony\"\n        ],\n        isOccupied: true,\n        tenantId: \"tenant-102\",\n        createdAt: \"2024-01-01T00:00:00Z\",\n        updatedAt: \"2024-01-16T10:00:00Z\"\n    },\n    {\n        id: \"room-103\",\n        roomNumber: \"103\",\n        floor: 1,\n        type: \"double\",\n        rent: 12000,\n        deposit: 24000,\n        amenities: [\n            \"AC\",\n            \"WiFi\",\n            \"Attached Bathroom\",\n            \"Balcony\"\n        ],\n        isOccupied: false,\n        createdAt: \"2024-01-01T00:00:00Z\",\n        updatedAt: \"2024-01-01T00:00:00Z\"\n    }\n];\nconst mockPayments = [\n    {\n        id: \"payment-1\",\n        tenantId: \"tenant-101\",\n        roomNumber: \"101\",\n        amount: 8000,\n        type: \"rent\",\n        month: \"2024-01\",\n        status: \"verified\",\n        paymentMethod: \"upi\",\n        transactionId: \"TXN123456789\",\n        receiptUrl: \"https://example.com/receipt1.pdf\",\n        submittedAt: \"2024-01-05T10:00:00Z\",\n        verifiedAt: \"2024-01-05T11:00:00Z\"\n    },\n    {\n        id: \"payment-2\",\n        tenantId: \"tenant-102\",\n        roomNumber: \"102\",\n        amount: 8500,\n        type: \"rent\",\n        month: \"2024-01\",\n        status: \"pending\",\n        paymentMethod: \"bank_transfer\",\n        transactionId: \"TXN987654321\",\n        receiptUrl: \"https://example.com/receipt2.pdf\",\n        submittedAt: \"2024-01-06T10:00:00Z\"\n    }\n];\nconst mockServiceRequests = [\n    {\n        id: \"service-1\",\n        tenantId: \"tenant-101\",\n        roomNumber: \"101\",\n        type: \"maintenance\",\n        title: \"AC not working\",\n        description: \"The air conditioner in my room is not cooling properly.\",\n        priority: \"high\",\n        status: \"in-progress\",\n        createdAt: \"2024-01-10T10:00:00Z\",\n        updatedAt: \"2024-01-11T10:00:00Z\"\n    },\n    {\n        id: \"service-2\",\n        tenantId: \"tenant-102\",\n        roomNumber: \"102\",\n        type: \"cleaning\",\n        title: \"Deep cleaning request\",\n        description: \"Need deep cleaning service for the room.\",\n        priority: \"medium\",\n        status: \"pending\",\n        createdAt: \"2024-01-12T10:00:00Z\",\n        updatedAt: \"2024-01-12T10:00:00Z\"\n    }\n];\nconst mockNotifications = [\n    {\n        id: \"notif-1\",\n        userId: \"tenant-101\",\n        type: \"payment\",\n        title: \"Payment Verified\",\n        message: \"Your rent payment for January 2024 has been verified.\",\n        read: false,\n        createdAt: \"2024-01-05T11:00:00Z\"\n    },\n    {\n        id: \"notif-2\",\n        userId: \"tenant-102\",\n        type: \"service\",\n        title: \"Service Request Update\",\n        message: \"Your maintenance request is now in progress.\",\n        read: false,\n        createdAt: \"2024-01-11T10:00:00Z\"\n    }\n];\nclass MockApiService {\n    delay() {\n        let ms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 500;\n        return new Promise((resolve)=>setTimeout(resolve, ms));\n    }\n    // Authentication APIs\n    async login(roomNumber, aadhaarNumber) {\n        await this.delay();\n        const tenant = mockTenants.find((t)=>t.roomNumber === roomNumber && t.aadhaarNumber === aadhaarNumber);\n        if (tenant) {\n            const user = {\n                uid: tenant.uid,\n                email: tenant.email,\n                role: \"tenant\",\n                roomNumber: tenant.roomNumber,\n                isOnboardingComplete: tenant.isOnboardingComplete\n            };\n            // Store auth token\n            localStorage.setItem(\"authToken\", \"mock-token-\".concat(tenant.uid));\n            return {\n                success: true,\n                data: user\n            };\n        }\n        return {\n            success: false,\n            error: \"Invalid credentials\"\n        };\n    }\n    async loginOwner(email, password) {\n        await this.delay();\n        if (email === \"owner@example.com\" && password === \"password\") {\n            const user = {\n                uid: \"owner-1\",\n                email: \"owner@example.com\",\n                role: \"owner\",\n                isOnboardingComplete: true\n            };\n            localStorage.setItem(\"authToken\", \"mock-token-owner-1\");\n            return {\n                success: true,\n                data: user\n            };\n        }\n        return {\n            success: false,\n            error: \"Invalid credentials\"\n        };\n    }\n    async logout() {\n        await this.delay(200);\n        localStorage.removeItem(\"authToken\");\n        return {\n            success: true\n        };\n    }\n    async refreshToken() {\n        await this.delay(200);\n        return {\n            success: true,\n            data: {\n                token: \"mock-refreshed-token\"\n            }\n        };\n    }\n    // Tenant APIs\n    async getTenantProfile(tenantId) {\n        await this.delay();\n        const tenant = mockTenants.find((t)=>t.uid === tenantId);\n        if (tenant) {\n            return {\n                success: true,\n                data: tenant\n            };\n        }\n        return {\n            success: false,\n            error: \"Tenant not found\"\n        };\n    }\n    async updateTenantProfile(tenantId, data) {\n        await this.delay();\n        const tenantIndex = mockTenants.findIndex((t)=>t.uid === tenantId);\n        if (tenantIndex !== -1) {\n            mockTenants[tenantIndex] = {\n                ...mockTenants[tenantIndex],\n                ...data\n            };\n            return {\n                success: true,\n                data: mockTenants[tenantIndex]\n            };\n        }\n        return {\n            success: false,\n            error: \"Tenant not found\"\n        };\n    }\n    async completeTenantOnboarding(tenantId, data) {\n        await this.delay();\n        return this.updateTenantProfile(tenantId, {\n            ...data,\n            isOnboardingComplete: true\n        });\n    }\n    async uploadTenantDocument(tenantId, file, type) {\n        await this.delay(1000);\n        return {\n            success: true,\n            data: {\n                url: \"https://example.com/\".concat(type, \"-\").concat(tenantId, \".pdf\")\n            }\n        };\n    }\n    // Owner APIs\n    async getAllTenants() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, filters = arguments.length > 2 ? arguments[2] : void 0;\n        await this.delay();\n        return {\n            success: true,\n            data: {\n                data: mockTenants,\n                total: mockTenants.length,\n                page,\n                limit,\n                hasMore: false\n            }\n        };\n    }\n    async getTenantById(tenantId) {\n        return this.getTenantProfile(tenantId);\n    }\n    async updateTenantByOwner(tenantId, data) {\n        return this.updateTenantProfile(tenantId, data);\n    }\n    async deleteTenant(tenantId) {\n        await this.delay();\n        const index = mockTenants.findIndex((t)=>t.uid === tenantId);\n        if (index !== -1) {\n            mockTenants.splice(index, 1);\n            return {\n                success: true\n            };\n        }\n        return {\n            success: false,\n            error: \"Tenant not found\"\n        };\n    }\n    // Room Management APIs\n    async getAllRooms() {\n        await this.delay();\n        return {\n            success: true,\n            data: mockRooms\n        };\n    }\n    async getRoomById(roomId) {\n        await this.delay();\n        const room = mockRooms.find((r)=>r.id === roomId);\n        if (room) {\n            return {\n                success: true,\n                data: room\n            };\n        }\n        return {\n            success: false,\n            error: \"Room not found\"\n        };\n    }\n    async createRoom(data) {\n        await this.delay();\n        const newRoom = {\n            ...data,\n            id: \"room-\".concat(Date.now()),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        mockRooms.push(newRoom);\n        return {\n            success: true,\n            data: newRoom\n        };\n    }\n    async updateRoom(roomId, data) {\n        await this.delay();\n        const roomIndex = mockRooms.findIndex((r)=>r.id === roomId);\n        if (roomIndex !== -1) {\n            mockRooms[roomIndex] = {\n                ...mockRooms[roomIndex],\n                ...data,\n                updatedAt: new Date().toISOString()\n            };\n            return {\n                success: true,\n                data: mockRooms[roomIndex]\n            };\n        }\n        return {\n            success: false,\n            error: \"Room not found\"\n        };\n    }\n    async deleteRoom(roomId) {\n        await this.delay();\n        const index = mockRooms.findIndex((r)=>r.id === roomId);\n        if (index !== -1) {\n            mockRooms.splice(index, 1);\n            return {\n                success: true\n            };\n        }\n        return {\n            success: false,\n            error: \"Room not found\"\n        };\n    }\n    async assignTenantToRoom(roomId, tenantId) {\n        await this.delay();\n        return this.updateRoom(roomId, {\n            tenantId,\n            isOccupied: true\n        });\n    }\n    async removeTenantFromRoom(roomId) {\n        await this.delay();\n        return this.updateRoom(roomId, {\n            tenantId: undefined,\n            isOccupied: false\n        });\n    }\n    // Payment APIs\n    async submitPayment(data) {\n        await this.delay();\n        const newPayment = {\n            ...data,\n            id: \"payment-\".concat(Date.now()),\n            submittedAt: new Date().toISOString()\n        };\n        mockPayments.unshift(newPayment);\n        return {\n            success: true,\n            data: newPayment\n        };\n    }\n    async getTenantPayments(tenantId) {\n        await this.delay();\n        const payments = mockPayments.filter((p)=>p.tenantId === tenantId);\n        return {\n            success: true,\n            data: payments\n        };\n    }\n    async getAllPayments() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, filters = arguments.length > 2 ? arguments[2] : void 0;\n        await this.delay();\n        return {\n            success: true,\n            data: {\n                data: mockPayments,\n                total: mockPayments.length,\n                page,\n                limit,\n                hasMore: false\n            }\n        };\n    }\n    async updatePaymentStatus(paymentId, status) {\n        await this.delay();\n        const paymentIndex = mockPayments.findIndex((p)=>p.id === paymentId);\n        if (paymentIndex !== -1) {\n            mockPayments[paymentIndex] = {\n                ...mockPayments[paymentIndex],\n                status,\n                verifiedAt: status === \"verified\" ? new Date().toISOString() : undefined\n            };\n            return {\n                success: true,\n                data: mockPayments[paymentIndex]\n            };\n        }\n        return {\n            success: false,\n            error: \"Payment not found\"\n        };\n    }\n    async verifyPayment(paymentId, verified) {\n        const status = verified ? \"verified\" : \"rejected\";\n        return this.updatePaymentStatus(paymentId, status);\n    }\n    // Service Request APIs\n    async createServiceRequest(data) {\n        await this.delay();\n        const newRequest = {\n            ...data,\n            id: \"service-\".concat(Date.now()),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        mockServiceRequests.unshift(newRequest);\n        return {\n            success: true,\n            data: newRequest\n        };\n    }\n    async getTenantServiceRequests(tenantId) {\n        await this.delay();\n        const requests = mockServiceRequests.filter((sr)=>sr.tenantId === tenantId);\n        return {\n            success: true,\n            data: requests\n        };\n    }\n    async getAllServiceRequests() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, filters = arguments.length > 2 ? arguments[2] : void 0;\n        await this.delay();\n        return {\n            success: true,\n            data: {\n                data: mockServiceRequests,\n                total: mockServiceRequests.length,\n                page,\n                limit,\n                hasMore: false\n            }\n        };\n    }\n    async updateServiceRequestStatus(requestId, status) {\n        await this.delay();\n        const requestIndex = mockServiceRequests.findIndex((sr)=>sr.id === requestId);\n        if (requestIndex !== -1) {\n            mockServiceRequests[requestIndex] = {\n                ...mockServiceRequests[requestIndex],\n                status,\n                updatedAt: new Date().toISOString()\n            };\n            return {\n                success: true,\n                data: mockServiceRequests[requestIndex]\n            };\n        }\n        return {\n            success: false,\n            error: \"Service request not found\"\n        };\n    }\n    async addServiceRequestNote(requestId, note) {\n        await this.delay();\n        const requestIndex = mockServiceRequests.findIndex((sr)=>sr.id === requestId);\n        if (requestIndex !== -1) {\n            const request = mockServiceRequests[requestIndex];\n            request.notes = request.notes || [];\n            request.notes.push({\n                id: \"note-\".concat(Date.now()),\n                text: note,\n                createdAt: new Date().toISOString(),\n                createdBy: \"owner-1\"\n            });\n            request.updatedAt = new Date().toISOString();\n            return {\n                success: true,\n                data: request\n            };\n        }\n        return {\n            success: false,\n            error: \"Service request not found\"\n        };\n    }\n    // Notification APIs\n    async getNotifications(userId) {\n        await this.delay();\n        const notifications = mockNotifications.filter((n)=>n.userId === userId);\n        return {\n            success: true,\n            data: notifications\n        };\n    }\n    async markNotificationAsRead(notificationId) {\n        await this.delay();\n        const notificationIndex = mockNotifications.findIndex((n)=>n.id === notificationId);\n        if (notificationIndex !== -1) {\n            mockNotifications[notificationIndex].read = true;\n            return {\n                success: true\n            };\n        }\n        return {\n            success: false,\n            error: \"Notification not found\"\n        };\n    }\n    async markAllNotificationsAsRead(userId) {\n        await this.delay();\n        mockNotifications.forEach((n)=>{\n            if (n.userId === userId) {\n                n.read = true;\n            }\n        });\n        return {\n            success: true\n        };\n    }\n    async sendNotification(data) {\n        await this.delay();\n        const newNotification = {\n            id: \"notif-\".concat(Date.now()),\n            userId: data.userId,\n            type: data.type,\n            title: data.title,\n            message: data.message,\n            actionUrl: data.actionUrl,\n            read: false,\n            createdAt: new Date().toISOString()\n        };\n        mockNotifications.unshift(newNotification);\n        return {\n            success: true,\n            data: newNotification\n        };\n    }\n    async sendBulkNotifications(data) {\n        await this.delay();\n        data.userIds.forEach((userId)=>{\n            const newNotification = {\n                id: \"notif-\".concat(Date.now(), \"-\").concat(userId),\n                userId,\n                type: data.type,\n                title: data.title,\n                message: data.message,\n                actionUrl: data.actionUrl,\n                read: false,\n                createdAt: new Date().toISOString()\n            };\n            mockNotifications.unshift(newNotification);\n        });\n        return {\n            success: true\n        };\n    }\n    // Analytics APIs\n    async getDashboardStats() {\n        await this.delay();\n        return {\n            success: true,\n            data: {\n                totalRooms: mockRooms.length,\n                occupiedRooms: mockRooms.filter((r)=>r.isOccupied).length,\n                totalTenants: mockTenants.length,\n                pendingPayments: mockPayments.filter((p)=>p.status === \"pending\").length,\n                totalRevenue: mockPayments.filter((p)=>p.status === \"verified\").reduce((sum, p)=>sum + p.amount, 0),\n                pendingServiceRequests: mockServiceRequests.filter((sr)=>sr.status === \"pending\").length\n            }\n        };\n    }\n    async getRevenueAnalytics(period) {\n        await this.delay();\n        return {\n            success: true,\n            data: {\n                period,\n                totalRevenue: 50000,\n                monthlyData: [\n                    {\n                        month: \"Jan\",\n                        revenue: 25000\n                    },\n                    {\n                        month: \"Feb\",\n                        revenue: 25000\n                    }\n                ]\n            }\n        };\n    }\n    async getOccupancyAnalytics(period) {\n        await this.delay();\n        return {\n            success: true,\n            data: {\n                period,\n                occupancyRate: 66.67,\n                monthlyData: [\n                    {\n                        month: \"Jan\",\n                        occupancy: 66.67\n                    },\n                    {\n                        month: \"Feb\",\n                        occupancy: 66.67\n                    }\n                ]\n            }\n        };\n    }\n    async getPaymentAnalytics(period) {\n        await this.delay();\n        return {\n            success: true,\n            data: {\n                period,\n                totalPayments: mockPayments.length,\n                verifiedPayments: mockPayments.filter((p)=>p.status === \"verified\").length,\n                pendingPayments: mockPayments.filter((p)=>p.status === \"pending\").length\n            }\n        };\n    }\n    async exportData(type) {\n        let format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"csv\";\n        await this.delay(2000);\n        return {\n            success: true,\n            data: {\n                downloadUrl: \"https://example.com/export-\".concat(type, \".\").concat(format)\n            }\n        };\n    }\n    // File Upload APIs\n    async uploadFile(file, type, metadata) {\n        await this.delay(1000);\n        return {\n            success: true,\n            data: {\n                url: \"https://example.com/uploads/\".concat(file.name),\n                id: \"file-\".concat(Date.now())\n            }\n        };\n    }\n    async deleteFile(fileId) {\n        await this.delay();\n        return {\n            success: true\n        };\n    }\n    // Real-time connection APIs (mock implementation)\n    async subscribeToUpdates(userId, callback) {\n        // Simulate real-time updates with periodic mock data\n        const interval = setInterval(()=>{\n            // Randomly send mock updates\n            if (Math.random() > 0.8) {\n                const updateTypes = [\n                    \"payment_submitted\",\n                    \"service_request_created\",\n                    \"notification\"\n                ];\n                const randomType = updateTypes[Math.floor(Math.random() * updateTypes.length)];\n                callback({\n                    type: randomType,\n                    data: {\n                        message: \"Mock \".concat(randomType, \" update\")\n                    },\n                    timestamp: new Date().toISOString()\n                });\n            }\n        }, 10000); // Send updates every 10 seconds\n        // Return cleanup function\n        return ()=>{\n            clearInterval(interval);\n        };\n    }\n}\nconst mockApiService = new MockApiService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFXOUYsSUFBVSxFQUFFcEQsSUFBWSxFQUFFbUosUUFBYyxFQUFxRDtRQUM1RyxNQUFNLElBQUksQ0FBQzNILEtBQUssQ0FBQztRQUNqQixPQUFPO1lBQ0xhLFNBQVM7WUFDVEMsTUFBTTtnQkFDSmUsS0FBSywrQkFBeUMsT0FBVkQsS0FBS25FLElBQUk7Z0JBQzdDYSxJQUFJLFFBQW1CLE9BQVgyRSxLQUFLQyxHQUFHO1lBQ3RCO1FBQ0Y7SUFDRjtJQUVBLE1BQU0wRSxXQUFXQyxNQUFjLEVBQThCO1FBQzNELE1BQU0sSUFBSSxDQUFDN0gsS0FBSztRQUNoQixPQUFPO1lBQUVhLFNBQVM7UUFBSztJQUN6QjtJQUVBLGtEQUFrRDtJQUNsRCxNQUFNaUgsbUJBQW1CbEksTUFBYyxFQUFFbUksUUFBNkIsRUFBdUI7UUFDM0YscURBQXFEO1FBQ3JELE1BQU1DLFdBQVdDLFlBQVk7WUFDM0IsNkJBQTZCO1lBQzdCLElBQUlDLEtBQUtDLE1BQU0sS0FBSyxLQUFLO2dCQUN2QixNQUFNQyxjQUFjO29CQUFDO29CQUFxQjtvQkFBMkI7aUJBQWU7Z0JBQ3BGLE1BQU1DLGFBQWFELFdBQVcsQ0FBQ0YsS0FBSzNKLEtBQUssQ0FBQzJKLEtBQUtDLE1BQU0sS0FBS0MsWUFBWWpHLE1BQU0sRUFBRTtnQkFFOUU0RixTQUFTO29CQUNQdkosTUFBTTZKO29CQUNOdkgsTUFBTTt3QkFBRWpCLFNBQVMsUUFBbUIsT0FBWHdJLFlBQVc7b0JBQVM7b0JBQzdDQyxXQUFXLElBQUlyRixPQUFPRSxXQUFXO2dCQUNuQztZQUNGO1FBQ0YsR0FBRyxRQUFRLGdDQUFnQztRQUUzQywwQkFBMEI7UUFDMUIsT0FBTztZQUNMb0YsY0FBY1A7UUFDaEI7SUFDRjtBQUNGO0FBRU8sTUFBTVEsaUJBQWlCLElBQUl6SSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL21vY2tBcGkudHM/NmFhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNb2NrIEFQSSBzZXJ2aWNlIHRvIHNpbXVsYXRlIGJhY2tlbmQgcmVzcG9uc2VzXG5pbXBvcnQgeyBcbiAgVXNlciwgXG4gIFRlbmFudFByb2ZpbGUsIFxuICBSb29tLCBcbiAgUGF5bWVudCwgXG4gIFNlcnZpY2VSZXF1ZXN0LCBcbiAgTm90aWZpY2F0aW9uIFxufSBmcm9tICcuLi90eXBlcyc7XG5cbmludGVyZmFjZSBBcGlSZXNwb25zZTxUPiB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIGRhdGE/OiBUO1xuICBlcnJvcj86IHN0cmluZztcbiAgbWVzc2FnZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFBhZ2luYXRlZFJlc3BvbnNlPFQ+IHtcbiAgZGF0YTogVFtdO1xuICB0b3RhbDogbnVtYmVyO1xuICBwYWdlOiBudW1iZXI7XG4gIGxpbWl0OiBudW1iZXI7XG4gIGhhc01vcmU6IGJvb2xlYW47XG59XG5cbi8vIE1vY2sgZGF0YVxuY29uc3QgbW9ja1RlbmFudHM6IFRlbmFudFByb2ZpbGVbXSA9IFtcbiAge1xuICAgIHVpZDogJ3RlbmFudC0xMDEnLFxuICAgIHJvb21OdW1iZXI6ICcxMDEnLFxuICAgIG5hbWU6ICdKb2huIERvZScsXG4gICAgZW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyxcbiAgICBwaG9uZTogJys5MSA5ODc2NTQzMjEwJyxcbiAgICBhYWRoYWFyTnVtYmVyOiAnMTIzNC01Njc4LTkwMTInLFxuICAgIGVtZXJnZW5jeUNvbnRhY3Q6IHtcbiAgICAgIG5hbWU6ICdKYW5lIERvZScsXG4gICAgICBwaG9uZTogJys5MSA5ODc2NTQzMjExJyxcbiAgICAgIHJlbGF0aW9uOiAnU2lzdGVyJ1xuICAgIH0sXG4gICAgZG9jdW1lbnRzOiB7XG4gICAgICBhYWRoYWFyOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9hYWRoYWFyLnBkZicsXG4gICAgICBwaG90bzogJ2h0dHBzOi8vZXhhbXBsZS5jb20vcGhvdG8uanBnJ1xuICAgIH0sXG4gICAgaXNPbmJvYXJkaW5nQ29tcGxldGU6IHRydWUsXG4gICAgY3JlYXRlZEF0OiAnMjAyNC0wMS0xNVQxMDowMDowMFonLFxuICAgIHVwZGF0ZWRBdDogJzIwMjQtMDEtMTVUMTA6MDA6MDBaJ1xuICB9LFxuICB7XG4gICAgdWlkOiAndGVuYW50LTEwMicsXG4gICAgcm9vbU51bWJlcjogJzEwMicsXG4gICAgbmFtZTogJ0FsaWNlIFNtaXRoJyxcbiAgICBlbWFpbDogJ2FsaWNlQGV4YW1wbGUuY29tJyxcbiAgICBwaG9uZTogJys5MSA5ODc2NTQzMjEyJyxcbiAgICBhYWRoYWFyTnVtYmVyOiAnMjM0NS02Nzg5LTAxMjMnLFxuICAgIGVtZXJnZW5jeUNvbnRhY3Q6IHtcbiAgICAgIG5hbWU6ICdCb2IgU21pdGgnLFxuICAgICAgcGhvbmU6ICcrOTEgOTg3NjU0MzIxMycsXG4gICAgICByZWxhdGlvbjogJ0h1c2JhbmQnXG4gICAgfSxcbiAgICBkb2N1bWVudHM6IHtcbiAgICAgIGFhZGhhYXI6ICdodHRwczovL2V4YW1wbGUuY29tL2FhZGhhYXIyLnBkZicsXG4gICAgICBwaG90bzogJ2h0dHBzOi8vZXhhbXBsZS5jb20vcGhvdG8yLmpwZydcbiAgICB9LFxuICAgIGlzT25ib2FyZGluZ0NvbXBsZXRlOiB0cnVlLFxuICAgIGNyZWF0ZWRBdDogJzIwMjQtMDEtMTZUMTA6MDA6MDBaJyxcbiAgICB1cGRhdGVkQXQ6ICcyMDI0LTAxLTE2VDEwOjAwOjAwWidcbiAgfVxuXTtcblxuY29uc3QgbW9ja1Jvb21zOiBSb29tW10gPSBbXG4gIHtcbiAgICBpZDogJ3Jvb20tMTAxJyxcbiAgICByb29tTnVtYmVyOiAnMTAxJyxcbiAgICBmbG9vcjogMSxcbiAgICB0eXBlOiAnc2luZ2xlJyxcbiAgICByZW50OiA4MDAwLFxuICAgIGRlcG9zaXQ6IDE2MDAwLFxuICAgIGFtZW5pdGllczogWydBQycsICdXaUZpJywgJ0F0dGFjaGVkIEJhdGhyb29tJ10sXG4gICAgaXNPY2N1cGllZDogdHJ1ZSxcbiAgICB0ZW5hbnRJZDogJ3RlbmFudC0xMDEnLFxuICAgIGNyZWF0ZWRBdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICB1cGRhdGVkQXQ6ICcyMDI0LTAxLTE1VDEwOjAwOjAwWidcbiAgfSxcbiAge1xuICAgIGlkOiAncm9vbS0xMDInLFxuICAgIHJvb21OdW1iZXI6ICcxMDInLFxuICAgIGZsb29yOiAxLFxuICAgIHR5cGU6ICdzaW5nbGUnLFxuICAgIHJlbnQ6IDg1MDAsXG4gICAgZGVwb3NpdDogMTcwMDAsXG4gICAgYW1lbml0aWVzOiBbJ0FDJywgJ1dpRmknLCAnQXR0YWNoZWQgQmF0aHJvb20nLCAnQmFsY29ueSddLFxuICAgIGlzT2NjdXBpZWQ6IHRydWUsXG4gICAgdGVuYW50SWQ6ICd0ZW5hbnQtMTAyJyxcbiAgICBjcmVhdGVkQXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgdXBkYXRlZEF0OiAnMjAyNC0wMS0xNlQxMDowMDowMFonXG4gIH0sXG4gIHtcbiAgICBpZDogJ3Jvb20tMTAzJyxcbiAgICByb29tTnVtYmVyOiAnMTAzJyxcbiAgICBmbG9vcjogMSxcbiAgICB0eXBlOiAnZG91YmxlJyxcbiAgICByZW50OiAxMjAwMCxcbiAgICBkZXBvc2l0OiAyNDAwMCxcbiAgICBhbWVuaXRpZXM6IFsnQUMnLCAnV2lGaScsICdBdHRhY2hlZCBCYXRocm9vbScsICdCYWxjb255J10sXG4gICAgaXNPY2N1cGllZDogZmFsc2UsXG4gICAgY3JlYXRlZEF0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgIHVwZGF0ZWRBdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJ1xuICB9XG5dO1xuXG5jb25zdCBtb2NrUGF5bWVudHM6IFBheW1lbnRbXSA9IFtcbiAge1xuICAgIGlkOiAncGF5bWVudC0xJyxcbiAgICB0ZW5hbnRJZDogJ3RlbmFudC0xMDEnLFxuICAgIHJvb21OdW1iZXI6ICcxMDEnLFxuICAgIGFtb3VudDogODAwMCxcbiAgICB0eXBlOiAncmVudCcsXG4gICAgbW9udGg6ICcyMDI0LTAxJyxcbiAgICBzdGF0dXM6ICd2ZXJpZmllZCcsXG4gICAgcGF5bWVudE1ldGhvZDogJ3VwaScsXG4gICAgdHJhbnNhY3Rpb25JZDogJ1RYTjEyMzQ1Njc4OScsXG4gICAgcmVjZWlwdFVybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vcmVjZWlwdDEucGRmJyxcbiAgICBzdWJtaXR0ZWRBdDogJzIwMjQtMDEtMDVUMTA6MDA6MDBaJyxcbiAgICB2ZXJpZmllZEF0OiAnMjAyNC0wMS0wNVQxMTowMDowMFonXG4gIH0sXG4gIHtcbiAgICBpZDogJ3BheW1lbnQtMicsXG4gICAgdGVuYW50SWQ6ICd0ZW5hbnQtMTAyJyxcbiAgICByb29tTnVtYmVyOiAnMTAyJyxcbiAgICBhbW91bnQ6IDg1MDAsXG4gICAgdHlwZTogJ3JlbnQnLFxuICAgIG1vbnRoOiAnMjAyNC0wMScsXG4gICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgcGF5bWVudE1ldGhvZDogJ2JhbmtfdHJhbnNmZXInLFxuICAgIHRyYW5zYWN0aW9uSWQ6ICdUWE45ODc2NTQzMjEnLFxuICAgIHJlY2VpcHRVcmw6ICdodHRwczovL2V4YW1wbGUuY29tL3JlY2VpcHQyLnBkZicsXG4gICAgc3VibWl0dGVkQXQ6ICcyMDI0LTAxLTA2VDEwOjAwOjAwWidcbiAgfVxuXTtcblxuY29uc3QgbW9ja1NlcnZpY2VSZXF1ZXN0czogU2VydmljZVJlcXVlc3RbXSA9IFtcbiAge1xuICAgIGlkOiAnc2VydmljZS0xJyxcbiAgICB0ZW5hbnRJZDogJ3RlbmFudC0xMDEnLFxuICAgIHJvb21OdW1iZXI6ICcxMDEnLFxuICAgIHR5cGU6ICdtYWludGVuYW5jZScsXG4gICAgdGl0bGU6ICdBQyBub3Qgd29ya2luZycsXG4gICAgZGVzY3JpcHRpb246ICdUaGUgYWlyIGNvbmRpdGlvbmVyIGluIG15IHJvb20gaXMgbm90IGNvb2xpbmcgcHJvcGVybHkuJyxcbiAgICBwcmlvcml0eTogJ2hpZ2gnLFxuICAgIHN0YXR1czogJ2luLXByb2dyZXNzJyxcbiAgICBjcmVhdGVkQXQ6ICcyMDI0LTAxLTEwVDEwOjAwOjAwWicsXG4gICAgdXBkYXRlZEF0OiAnMjAyNC0wMS0xMVQxMDowMDowMFonXG4gIH0sXG4gIHtcbiAgICBpZDogJ3NlcnZpY2UtMicsXG4gICAgdGVuYW50SWQ6ICd0ZW5hbnQtMTAyJyxcbiAgICByb29tTnVtYmVyOiAnMTAyJyxcbiAgICB0eXBlOiAnY2xlYW5pbmcnLFxuICAgIHRpdGxlOiAnRGVlcCBjbGVhbmluZyByZXF1ZXN0JyxcbiAgICBkZXNjcmlwdGlvbjogJ05lZWQgZGVlcCBjbGVhbmluZyBzZXJ2aWNlIGZvciB0aGUgcm9vbS4nLFxuICAgIHByaW9yaXR5OiAnbWVkaXVtJyxcbiAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICBjcmVhdGVkQXQ6ICcyMDI0LTAxLTEyVDEwOjAwOjAwWicsXG4gICAgdXBkYXRlZEF0OiAnMjAyNC0wMS0xMlQxMDowMDowMFonXG4gIH1cbl07XG5cbmNvbnN0IG1vY2tOb3RpZmljYXRpb25zOiBOb3RpZmljYXRpb25bXSA9IFtcbiAge1xuICAgIGlkOiAnbm90aWYtMScsXG4gICAgdXNlcklkOiAndGVuYW50LTEwMScsXG4gICAgdHlwZTogJ3BheW1lbnQnLFxuICAgIHRpdGxlOiAnUGF5bWVudCBWZXJpZmllZCcsXG4gICAgbWVzc2FnZTogJ1lvdXIgcmVudCBwYXltZW50IGZvciBKYW51YXJ5IDIwMjQgaGFzIGJlZW4gdmVyaWZpZWQuJyxcbiAgICByZWFkOiBmYWxzZSxcbiAgICBjcmVhdGVkQXQ6ICcyMDI0LTAxLTA1VDExOjAwOjAwWidcbiAgfSxcbiAge1xuICAgIGlkOiAnbm90aWYtMicsXG4gICAgdXNlcklkOiAndGVuYW50LTEwMicsXG4gICAgdHlwZTogJ3NlcnZpY2UnLFxuICAgIHRpdGxlOiAnU2VydmljZSBSZXF1ZXN0IFVwZGF0ZScsXG4gICAgbWVzc2FnZTogJ1lvdXIgbWFpbnRlbmFuY2UgcmVxdWVzdCBpcyBub3cgaW4gcHJvZ3Jlc3MuJyxcbiAgICByZWFkOiBmYWxzZSxcbiAgICBjcmVhdGVkQXQ6ICcyMDI0LTAxLTExVDEwOjAwOjAwWidcbiAgfVxuXTtcblxuY2xhc3MgTW9ja0FwaVNlcnZpY2Uge1xuICBwcml2YXRlIGRlbGF5KG1zOiBudW1iZXIgPSA1MDApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG4gIH1cblxuICAvLyBBdXRoZW50aWNhdGlvbiBBUElzXG4gIGFzeW5jIGxvZ2luKHJvb21OdW1iZXI6IHN0cmluZywgYWFkaGFhck51bWJlcjogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxVc2VyPj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICBcbiAgICBjb25zdCB0ZW5hbnQgPSBtb2NrVGVuYW50cy5maW5kKHQgPT4gXG4gICAgICB0LnJvb21OdW1iZXIgPT09IHJvb21OdW1iZXIgJiYgdC5hYWRoYWFyTnVtYmVyID09PSBhYWRoYWFyTnVtYmVyXG4gICAgKTtcbiAgICBcbiAgICBpZiAodGVuYW50KSB7XG4gICAgICBjb25zdCB1c2VyOiBVc2VyID0ge1xuICAgICAgICB1aWQ6IHRlbmFudC51aWQsXG4gICAgICAgIGVtYWlsOiB0ZW5hbnQuZW1haWwsXG4gICAgICAgIHJvbGU6ICd0ZW5hbnQnLFxuICAgICAgICByb29tTnVtYmVyOiB0ZW5hbnQucm9vbU51bWJlcixcbiAgICAgICAgaXNPbmJvYXJkaW5nQ29tcGxldGU6IHRlbmFudC5pc09uYm9hcmRpbmdDb21wbGV0ZVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgYXV0aCB0b2tlblxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIGBtb2NrLXRva2VuLSR7dGVuYW50LnVpZH1gKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogdXNlclxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdJbnZhbGlkIGNyZWRlbnRpYWxzJ1xuICAgIH07XG4gIH1cblxuICBhc3luYyBsb2dpbk93bmVyKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFVzZXI+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgpO1xuICAgIFxuICAgIGlmIChlbWFpbCA9PT0gJ293bmVyQGV4YW1wbGUuY29tJyAmJiBwYXNzd29yZCA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgY29uc3QgdXNlcjogVXNlciA9IHtcbiAgICAgICAgdWlkOiAnb3duZXItMScsXG4gICAgICAgIGVtYWlsOiAnb3duZXJAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlOiAnb3duZXInLFxuICAgICAgICBpc09uYm9hcmRpbmdDb21wbGV0ZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsICdtb2NrLXRva2VuLW93bmVyLTEnKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogdXNlclxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdJbnZhbGlkIGNyZWRlbnRpYWxzJ1xuICAgIH07XG4gIH1cblxuICBhc3luYyBsb2dvdXQoKTogUHJvbWlzZTxBcGlSZXNwb25zZTx2b2lkPj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoMjAwKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYXV0aFRva2VuJyk7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICB9XG5cbiAgYXN5bmMgcmVmcmVzaFRva2VuKCk6IFByb21pc2U8QXBpUmVzcG9uc2U8eyB0b2tlbjogc3RyaW5nIH0+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgyMDApO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YTogeyB0b2tlbjogJ21vY2stcmVmcmVzaGVkLXRva2VuJyB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFRlbmFudCBBUElzXG4gIGFzeW5jIGdldFRlbmFudFByb2ZpbGUodGVuYW50SWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8VGVuYW50UHJvZmlsZT4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgY29uc3QgdGVuYW50ID0gbW9ja1RlbmFudHMuZmluZCh0ID0+IHQudWlkID09PSB0ZW5hbnRJZCk7XG4gICAgXG4gICAgaWYgKHRlbmFudCkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogdGVuYW50IH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1RlbmFudCBub3QgZm91bmQnIH07XG4gIH1cblxuICBhc3luYyB1cGRhdGVUZW5hbnRQcm9maWxlKHRlbmFudElkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8VGVuYW50UHJvZmlsZT4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPFRlbmFudFByb2ZpbGU+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgpO1xuICAgIGNvbnN0IHRlbmFudEluZGV4ID0gbW9ja1RlbmFudHMuZmluZEluZGV4KHQgPT4gdC51aWQgPT09IHRlbmFudElkKTtcbiAgICBcbiAgICBpZiAodGVuYW50SW5kZXggIT09IC0xKSB7XG4gICAgICBtb2NrVGVuYW50c1t0ZW5hbnRJbmRleF0gPSB7IC4uLm1vY2tUZW5hbnRzW3RlbmFudEluZGV4XSwgLi4uZGF0YSB9O1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja1RlbmFudHNbdGVuYW50SW5kZXhdIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1RlbmFudCBub3QgZm91bmQnIH07XG4gIH1cblxuICBhc3luYyBjb21wbGV0ZVRlbmFudE9uYm9hcmRpbmcodGVuYW50SWQ6IHN0cmluZywgZGF0YTogYW55KTogUHJvbWlzZTxBcGlSZXNwb25zZTxUZW5hbnRQcm9maWxlPj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVUZW5hbnRQcm9maWxlKHRlbmFudElkLCB7IC4uLmRhdGEsIGlzT25ib2FyZGluZ0NvbXBsZXRlOiB0cnVlIH0pO1xuICB9XG5cbiAgYXN5bmMgdXBsb2FkVGVuYW50RG9jdW1lbnQodGVuYW50SWQ6IHN0cmluZywgZmlsZTogRmlsZSwgdHlwZTogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTx7IHVybDogc3RyaW5nIH0+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgxMDAwKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGRhdGE6IHsgdXJsOiBgaHR0cHM6Ly9leGFtcGxlLmNvbS8ke3R5cGV9LSR7dGVuYW50SWR9LnBkZmAgfVxuICAgIH07XG4gIH1cblxuICAvLyBPd25lciBBUElzXG4gIGFzeW5jIGdldEFsbFRlbmFudHMocGFnZSA9IDEsIGxpbWl0ID0gMjAsIGZpbHRlcnM/OiBhbnkpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFBhZ2luYXRlZFJlc3BvbnNlPFRlbmFudFByb2ZpbGU+Pj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZGF0YTogbW9ja1RlbmFudHMsXG4gICAgICAgIHRvdGFsOiBtb2NrVGVuYW50cy5sZW5ndGgsXG4gICAgICAgIHBhZ2UsXG4gICAgICAgIGxpbWl0LFxuICAgICAgICBoYXNNb3JlOiBmYWxzZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBhc3luYyBnZXRUZW5hbnRCeUlkKHRlbmFudElkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFRlbmFudFByb2ZpbGU+PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGVuYW50UHJvZmlsZSh0ZW5hbnRJZCk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVUZW5hbnRCeU93bmVyKHRlbmFudElkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8VGVuYW50UHJvZmlsZT4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPFRlbmFudFByb2ZpbGU+PiB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVGVuYW50UHJvZmlsZSh0ZW5hbnRJZCwgZGF0YSk7XG4gIH1cblxuICBhc3luYyBkZWxldGVUZW5hbnQodGVuYW50SWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8dm9pZD4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgY29uc3QgaW5kZXggPSBtb2NrVGVuYW50cy5maW5kSW5kZXgodCA9PiB0LnVpZCA9PT0gdGVuYW50SWQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIG1vY2tUZW5hbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1RlbmFudCBub3QgZm91bmQnIH07XG4gIH1cblxuICAvLyBSb29tIE1hbmFnZW1lbnQgQVBJc1xuICBhc3luYyBnZXRBbGxSb29tcygpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFJvb21bXT4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja1Jvb21zIH07XG4gIH1cblxuICBhc3luYyBnZXRSb29tQnlJZChyb29tSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8Um9vbT4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgY29uc3Qgcm9vbSA9IG1vY2tSb29tcy5maW5kKHIgPT4gci5pZCA9PT0gcm9vbUlkKTtcbiAgICBpZiAocm9vbSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcm9vbSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdSb29tIG5vdCBmb3VuZCcgfTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZVJvb20oZGF0YTogT21pdDxSb29tLCAnaWQnPik6IFByb21pc2U8QXBpUmVzcG9uc2U8Um9vbT4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgY29uc3QgbmV3Um9vbTogUm9vbSA9IHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBpZDogYHJvb20tJHtEYXRlLm5vdygpfWAsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBtb2NrUm9vbXMucHVzaChuZXdSb29tKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBuZXdSb29tIH07XG4gIH1cblxuICBhc3luYyB1cGRhdGVSb29tKHJvb21JZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPFJvb20+KTogUHJvbWlzZTxBcGlSZXNwb25zZTxSb29tPj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICBjb25zdCByb29tSW5kZXggPSBtb2NrUm9vbXMuZmluZEluZGV4KHIgPT4gci5pZCA9PT0gcm9vbUlkKTtcbiAgICBpZiAocm9vbUluZGV4ICE9PSAtMSkge1xuICAgICAgbW9ja1Jvb21zW3Jvb21JbmRleF0gPSB7IC4uLm1vY2tSb29tc1tyb29tSW5kZXhdLCAuLi5kYXRhLCB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9O1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja1Jvb21zW3Jvb21JbmRleF0gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnUm9vbSBub3QgZm91bmQnIH07XG4gIH1cblxuICBhc3luYyBkZWxldGVSb29tKHJvb21JZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTx2b2lkPj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICBjb25zdCBpbmRleCA9IG1vY2tSb29tcy5maW5kSW5kZXgociA9PiByLmlkID09PSByb29tSWQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIG1vY2tSb29tcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdSb29tIG5vdCBmb3VuZCcgfTtcbiAgfVxuXG4gIGFzeW5jIGFzc2lnblRlbmFudFRvUm9vbShyb29tSWQ6IHN0cmluZywgdGVuYW50SWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8Um9vbT4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlUm9vbShyb29tSWQsIHsgdGVuYW50SWQsIGlzT2NjdXBpZWQ6IHRydWUgfSk7XG4gIH1cblxuICBhc3luYyByZW1vdmVUZW5hbnRGcm9tUm9vbShyb29tSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8Um9vbT4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlUm9vbShyb29tSWQsIHsgdGVuYW50SWQ6IHVuZGVmaW5lZCwgaXNPY2N1cGllZDogZmFsc2UgfSk7XG4gIH1cblxuICAvLyBQYXltZW50IEFQSXNcbiAgYXN5bmMgc3VibWl0UGF5bWVudChkYXRhOiBPbWl0PFBheW1lbnQsICdpZCc+KTogUHJvbWlzZTxBcGlSZXNwb25zZTxQYXltZW50Pj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICBjb25zdCBuZXdQYXltZW50OiBQYXltZW50ID0ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGlkOiBgcGF5bWVudC0ke0RhdGUubm93KCl9YCxcbiAgICAgIHN1Ym1pdHRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuICAgIG1vY2tQYXltZW50cy51bnNoaWZ0KG5ld1BheW1lbnQpO1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG5ld1BheW1lbnQgfTtcbiAgfVxuXG4gIGFzeW5jIGdldFRlbmFudFBheW1lbnRzKHRlbmFudElkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFBheW1lbnRbXT4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgY29uc3QgcGF5bWVudHMgPSBtb2NrUGF5bWVudHMuZmlsdGVyKHAgPT4gcC50ZW5hbnRJZCA9PT0gdGVuYW50SWQpO1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHBheW1lbnRzIH07XG4gIH1cblxuICBhc3luYyBnZXRBbGxQYXltZW50cyhwYWdlID0gMSwgbGltaXQgPSAyMCwgZmlsdGVycz86IGFueSk6IFByb21pc2U8QXBpUmVzcG9uc2U8UGFnaW5hdGVkUmVzcG9uc2U8UGF5bWVudD4+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRhOiBtb2NrUGF5bWVudHMsXG4gICAgICAgIHRvdGFsOiBtb2NrUGF5bWVudHMubGVuZ3RoLFxuICAgICAgICBwYWdlLFxuICAgICAgICBsaW1pdCxcbiAgICAgICAgaGFzTW9yZTogZmFsc2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlUGF5bWVudFN0YXR1cyhwYXltZW50SWQ6IHN0cmluZywgc3RhdHVzOiBQYXltZW50WydzdGF0dXMnXSk6IFByb21pc2U8QXBpUmVzcG9uc2U8UGF5bWVudD4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgY29uc3QgcGF5bWVudEluZGV4ID0gbW9ja1BheW1lbnRzLmZpbmRJbmRleChwID0+IHAuaWQgPT09IHBheW1lbnRJZCk7XG4gICAgaWYgKHBheW1lbnRJbmRleCAhPT0gLTEpIHtcbiAgICAgIG1vY2tQYXltZW50c1twYXltZW50SW5kZXhdID0geyBcbiAgICAgICAgLi4ubW9ja1BheW1lbnRzW3BheW1lbnRJbmRleF0sIFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIHZlcmlmaWVkQXQ6IHN0YXR1cyA9PT0gJ3ZlcmlmaWVkJyA/IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSA6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG1vY2tQYXltZW50c1twYXltZW50SW5kZXhdIH07XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1BheW1lbnQgbm90IGZvdW5kJyB9O1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5UGF5bWVudChwYXltZW50SWQ6IHN0cmluZywgdmVyaWZpZWQ6IGJvb2xlYW4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPFBheW1lbnQ+PiB7XG4gICAgY29uc3Qgc3RhdHVzID0gdmVyaWZpZWQgPyAndmVyaWZpZWQnIDogJ3JlamVjdGVkJztcbiAgICByZXR1cm4gdGhpcy51cGRhdGVQYXltZW50U3RhdHVzKHBheW1lbnRJZCwgc3RhdHVzKTtcbiAgfVxuXG4gIC8vIFNlcnZpY2UgUmVxdWVzdCBBUElzXG4gIGFzeW5jIGNyZWF0ZVNlcnZpY2VSZXF1ZXN0KGRhdGE6IE9taXQ8U2VydmljZVJlcXVlc3QsICdpZCc+KTogUHJvbWlzZTxBcGlSZXNwb25zZTxTZXJ2aWNlUmVxdWVzdD4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgY29uc3QgbmV3UmVxdWVzdDogU2VydmljZVJlcXVlc3QgPSB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgaWQ6IGBzZXJ2aWNlLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgbW9ja1NlcnZpY2VSZXF1ZXN0cy51bnNoaWZ0KG5ld1JlcXVlc3QpO1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG5ld1JlcXVlc3QgfTtcbiAgfVxuXG4gIGFzeW5jIGdldFRlbmFudFNlcnZpY2VSZXF1ZXN0cyh0ZW5hbnRJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxTZXJ2aWNlUmVxdWVzdFtdPj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICBjb25zdCByZXF1ZXN0cyA9IG1vY2tTZXJ2aWNlUmVxdWVzdHMuZmlsdGVyKHNyID0+IHNyLnRlbmFudElkID09PSB0ZW5hbnRJZCk7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVxdWVzdHMgfTtcbiAgfVxuXG4gIGFzeW5jIGdldEFsbFNlcnZpY2VSZXF1ZXN0cyhwYWdlID0gMSwgbGltaXQgPSAyMCwgZmlsdGVycz86IGFueSk6IFByb21pc2U8QXBpUmVzcG9uc2U8UGFnaW5hdGVkUmVzcG9uc2U8U2VydmljZVJlcXVlc3Q+Pj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZGF0YTogbW9ja1NlcnZpY2VSZXF1ZXN0cyxcbiAgICAgICAgdG90YWw6IG1vY2tTZXJ2aWNlUmVxdWVzdHMubGVuZ3RoLFxuICAgICAgICBwYWdlLFxuICAgICAgICBsaW1pdCxcbiAgICAgICAgaGFzTW9yZTogZmFsc2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlU2VydmljZVJlcXVlc3RTdGF0dXMocmVxdWVzdElkOiBzdHJpbmcsIHN0YXR1czogU2VydmljZVJlcXVlc3RbJ3N0YXR1cyddKTogUHJvbWlzZTxBcGlSZXNwb25zZTxTZXJ2aWNlUmVxdWVzdD4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgY29uc3QgcmVxdWVzdEluZGV4ID0gbW9ja1NlcnZpY2VSZXF1ZXN0cy5maW5kSW5kZXgoc3IgPT4gc3IuaWQgPT09IHJlcXVlc3RJZCk7XG4gICAgaWYgKHJlcXVlc3RJbmRleCAhPT0gLTEpIHtcbiAgICAgIG1vY2tTZXJ2aWNlUmVxdWVzdHNbcmVxdWVzdEluZGV4XSA9IHsgXG4gICAgICAgIC4uLm1vY2tTZXJ2aWNlUmVxdWVzdHNbcmVxdWVzdEluZGV4XSwgXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrU2VydmljZVJlcXVlc3RzW3JlcXVlc3RJbmRleF0gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnU2VydmljZSByZXF1ZXN0IG5vdCBmb3VuZCcgfTtcbiAgfVxuXG4gIGFzeW5jIGFkZFNlcnZpY2VSZXF1ZXN0Tm90ZShyZXF1ZXN0SWQ6IHN0cmluZywgbm90ZTogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxTZXJ2aWNlUmVxdWVzdD4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgY29uc3QgcmVxdWVzdEluZGV4ID0gbW9ja1NlcnZpY2VSZXF1ZXN0cy5maW5kSW5kZXgoc3IgPT4gc3IuaWQgPT09IHJlcXVlc3RJZCk7XG4gICAgaWYgKHJlcXVlc3RJbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBtb2NrU2VydmljZVJlcXVlc3RzW3JlcXVlc3RJbmRleF07XG4gICAgICByZXF1ZXN0Lm5vdGVzID0gcmVxdWVzdC5ub3RlcyB8fCBbXTtcbiAgICAgIHJlcXVlc3Qubm90ZXMucHVzaCh7XG4gICAgICAgIGlkOiBgbm90ZS0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgdGV4dDogbm90ZSxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNyZWF0ZWRCeTogJ293bmVyLTEnXG4gICAgICB9KTtcbiAgICAgIHJlcXVlc3QudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVxdWVzdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdTZXJ2aWNlIHJlcXVlc3Qgbm90IGZvdW5kJyB9O1xuICB9XG5cbiAgLy8gTm90aWZpY2F0aW9uIEFQSXNcbiAgYXN5bmMgZ2V0Tm90aWZpY2F0aW9ucyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8Tm90aWZpY2F0aW9uW10+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgpO1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBtb2NrTm90aWZpY2F0aW9ucy5maWx0ZXIobiA9PiBuLnVzZXJJZCA9PT0gdXNlcklkKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBub3RpZmljYXRpb25zIH07XG4gIH1cblxuICBhc3luYyBtYXJrTm90aWZpY2F0aW9uQXNSZWFkKG5vdGlmaWNhdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHZvaWQ+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgpO1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbkluZGV4ID0gbW9ja05vdGlmaWNhdGlvbnMuZmluZEluZGV4KG4gPT4gbi5pZCA9PT0gbm90aWZpY2F0aW9uSWQpO1xuICAgIGlmIChub3RpZmljYXRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgIG1vY2tOb3RpZmljYXRpb25zW25vdGlmaWNhdGlvbkluZGV4XS5yZWFkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnTm90aWZpY2F0aW9uIG5vdCBmb3VuZCcgfTtcbiAgfVxuXG4gIGFzeW5jIG1hcmtBbGxOb3RpZmljYXRpb25zQXNSZWFkKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTx2b2lkPj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICBtb2NrTm90aWZpY2F0aW9ucy5mb3JFYWNoKG4gPT4ge1xuICAgICAgaWYgKG4udXNlcklkID09PSB1c2VySWQpIHtcbiAgICAgICAgbi5yZWFkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gIH1cblxuICBhc3luYyBzZW5kTm90aWZpY2F0aW9uKGRhdGE6IHtcbiAgICB1c2VySWQ6IHN0cmluZztcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgYWN0aW9uVXJsPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxBcGlSZXNwb25zZTxOb3RpZmljYXRpb24+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgpO1xuICAgIGNvbnN0IG5ld05vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uID0ge1xuICAgICAgaWQ6IGBub3RpZi0ke0RhdGUubm93KCl9YCxcbiAgICAgIHVzZXJJZDogZGF0YS51c2VySWQsXG4gICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICAgIG1lc3NhZ2U6IGRhdGEubWVzc2FnZSxcbiAgICAgIGFjdGlvblVybDogZGF0YS5hY3Rpb25VcmwsXG4gICAgICByZWFkOiBmYWxzZSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBtb2NrTm90aWZpY2F0aW9ucy51bnNoaWZ0KG5ld05vdGlmaWNhdGlvbik7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbmV3Tm90aWZpY2F0aW9uIH07XG4gIH1cblxuICBhc3luYyBzZW5kQnVsa05vdGlmaWNhdGlvbnMoZGF0YToge1xuICAgIHVzZXJJZHM6IHN0cmluZ1tdO1xuICAgIHR5cGU6IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICBhY3Rpb25Vcmw/OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPEFwaVJlc3BvbnNlPHZvaWQ+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgpO1xuICAgIGRhdGEudXNlcklkcy5mb3JFYWNoKHVzZXJJZCA9PiB7XG4gICAgICBjb25zdCBuZXdOb3RpZmljYXRpb246IE5vdGlmaWNhdGlvbiA9IHtcbiAgICAgICAgaWQ6IGBub3RpZi0ke0RhdGUubm93KCl9LSR7dXNlcklkfWAsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgdHlwZTogZGF0YS50eXBlLFxuICAgICAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICAgICAgbWVzc2FnZTogZGF0YS5tZXNzYWdlLFxuICAgICAgICBhY3Rpb25Vcmw6IGRhdGEuYWN0aW9uVXJsLFxuICAgICAgICByZWFkOiBmYWxzZSxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG4gICAgICBtb2NrTm90aWZpY2F0aW9ucy51bnNoaWZ0KG5ld05vdGlmaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICB9XG5cbiAgLy8gQW5hbHl0aWNzIEFQSXNcbiAgYXN5bmMgZ2V0RGFzaGJvYXJkU3RhdHMoKTogUHJvbWlzZTxBcGlSZXNwb25zZTxhbnk+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YToge1xuICAgICAgICB0b3RhbFJvb21zOiBtb2NrUm9vbXMubGVuZ3RoLFxuICAgICAgICBvY2N1cGllZFJvb21zOiBtb2NrUm9vbXMuZmlsdGVyKHIgPT4gci5pc09jY3VwaWVkKS5sZW5ndGgsXG4gICAgICAgIHRvdGFsVGVuYW50czogbW9ja1RlbmFudHMubGVuZ3RoLFxuICAgICAgICBwZW5kaW5nUGF5bWVudHM6IG1vY2tQYXltZW50cy5maWx0ZXIocCA9PiBwLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKS5sZW5ndGgsXG4gICAgICAgIHRvdGFsUmV2ZW51ZTogbW9ja1BheW1lbnRzLmZpbHRlcihwID0+IHAuc3RhdHVzID09PSAndmVyaWZpZWQnKS5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5hbW91bnQsIDApLFxuICAgICAgICBwZW5kaW5nU2VydmljZVJlcXVlc3RzOiBtb2NrU2VydmljZVJlcXVlc3RzLmZpbHRlcihzciA9PiBzci5zdGF0dXMgPT09ICdwZW5kaW5nJykubGVuZ3RoXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldFJldmVudWVBbmFseXRpY3MocGVyaW9kOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPGFueT4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBlcmlvZCxcbiAgICAgICAgdG90YWxSZXZlbnVlOiA1MDAwMCxcbiAgICAgICAgbW9udGhseURhdGE6IFtcbiAgICAgICAgICB7IG1vbnRoOiAnSmFuJywgcmV2ZW51ZTogMjUwMDAgfSxcbiAgICAgICAgICB7IG1vbnRoOiAnRmViJywgcmV2ZW51ZTogMjUwMDAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldE9jY3VwYW5jeUFuYWx5dGljcyhwZXJpb2Q6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8YW55Pj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcGVyaW9kLFxuICAgICAgICBvY2N1cGFuY3lSYXRlOiA2Ni42NyxcbiAgICAgICAgbW9udGhseURhdGE6IFtcbiAgICAgICAgICB7IG1vbnRoOiAnSmFuJywgb2NjdXBhbmN5OiA2Ni42NyB9LFxuICAgICAgICAgIHsgbW9udGg6ICdGZWInLCBvY2N1cGFuY3k6IDY2LjY3IH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBhc3luYyBnZXRQYXltZW50QW5hbHl0aWNzKHBlcmlvZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxhbnk+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YToge1xuICAgICAgICBwZXJpb2QsXG4gICAgICAgIHRvdGFsUGF5bWVudHM6IG1vY2tQYXltZW50cy5sZW5ndGgsXG4gICAgICAgIHZlcmlmaWVkUGF5bWVudHM6IG1vY2tQYXltZW50cy5maWx0ZXIocCA9PiBwLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJykubGVuZ3RoLFxuICAgICAgICBwZW5kaW5nUGF5bWVudHM6IG1vY2tQYXltZW50cy5maWx0ZXIocCA9PiBwLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKS5sZW5ndGhcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgZXhwb3J0RGF0YSh0eXBlOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nID0gJ2NzdicpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHsgZG93bmxvYWRVcmw6IHN0cmluZyB9Pj4ge1xuICAgIGF3YWl0IHRoaXMuZGVsYXkoMjAwMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiB7IGRvd25sb2FkVXJsOiBgaHR0cHM6Ly9leGFtcGxlLmNvbS9leHBvcnQtJHt0eXBlfS4ke2Zvcm1hdH1gIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRmlsZSBVcGxvYWQgQVBJc1xuICBhc3luYyB1cGxvYWRGaWxlKGZpbGU6IEZpbGUsIHR5cGU6IHN0cmluZywgbWV0YWRhdGE/OiBhbnkpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHsgdXJsOiBzdHJpbmc7IGlkOiBzdHJpbmcgfT4+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGF5KDEwMDApO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YToge1xuICAgICAgICB1cmw6IGBodHRwczovL2V4YW1wbGUuY29tL3VwbG9hZHMvJHtmaWxlLm5hbWV9YCxcbiAgICAgICAgaWQ6IGBmaWxlLSR7RGF0ZS5ub3coKX1gXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZUZpbGUoZmlsZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHZvaWQ+PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxheSgpO1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgfVxuXG4gIC8vIFJlYWwtdGltZSBjb25uZWN0aW9uIEFQSXMgKG1vY2sgaW1wbGVtZW50YXRpb24pXG4gIGFzeW5jIHN1YnNjcmliZVRvVXBkYXRlcyh1c2VySWQ6IHN0cmluZywgY2FsbGJhY2s6IChkYXRhOiBhbnkpID0+IHZvaWQpOiBQcm9taXNlPCgpID0+IHZvaWQ+IHtcbiAgICAvLyBTaW11bGF0ZSByZWFsLXRpbWUgdXBkYXRlcyB3aXRoIHBlcmlvZGljIG1vY2sgZGF0YVxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgLy8gUmFuZG9tbHkgc2VuZCBtb2NrIHVwZGF0ZXNcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC44KSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVR5cGVzID0gWydwYXltZW50X3N1Ym1pdHRlZCcsICdzZXJ2aWNlX3JlcXVlc3RfY3JlYXRlZCcsICdub3RpZmljYXRpb24nXTtcbiAgICAgICAgY29uc3QgcmFuZG9tVHlwZSA9IHVwZGF0ZVR5cGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHVwZGF0ZVR5cGVzLmxlbmd0aCldO1xuICAgICAgICBcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgIHR5cGU6IHJhbmRvbVR5cGUsXG4gICAgICAgICAgZGF0YTogeyBtZXNzYWdlOiBgTW9jayAke3JhbmRvbVR5cGV9IHVwZGF0ZWAgfSxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCAxMDAwMCk7IC8vIFNlbmQgdXBkYXRlcyBldmVyeSAxMCBzZWNvbmRzXG5cbiAgICAvLyBSZXR1cm4gY2xlYW51cCBmdW5jdGlvblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtb2NrQXBpU2VydmljZSA9IG5ldyBNb2NrQXBpU2VydmljZSgpOyJdLCJuYW1lcyI6WyJtb2NrVGVuYW50cyIsInVpZCIsInJvb21OdW1iZXIiLCJuYW1lIiwiZW1haWwiLCJwaG9uZSIsImFhZGhhYXJOdW1iZXIiLCJlbWVyZ2VuY3lDb250YWN0IiwicmVsYXRpb24iLCJkb2N1bWVudHMiLCJhYWRoYWFyIiwicGhvdG8iLCJpc09uYm9hcmRpbmdDb21wbGV0ZSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsIm1vY2tSb29tcyIsImlkIiwiZmxvb3IiLCJ0eXBlIiwicmVudCIsImRlcG9zaXQiLCJhbWVuaXRpZXMiLCJpc09jY3VwaWVkIiwidGVuYW50SWQiLCJtb2NrUGF5bWVudHMiLCJhbW91bnQiLCJtb250aCIsInN0YXR1cyIsInBheW1lbnRNZXRob2QiLCJ0cmFuc2FjdGlvbklkIiwicmVjZWlwdFVybCIsInN1Ym1pdHRlZEF0IiwidmVyaWZpZWRBdCIsIm1vY2tTZXJ2aWNlUmVxdWVzdHMiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwicHJpb3JpdHkiLCJtb2NrTm90aWZpY2F0aW9ucyIsInVzZXJJZCIsIm1lc3NhZ2UiLCJyZWFkIiwiTW9ja0FwaVNlcnZpY2UiLCJkZWxheSIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibG9naW4iLCJ0ZW5hbnQiLCJmaW5kIiwidCIsInVzZXIiLCJyb2xlIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInN1Y2Nlc3MiLCJkYXRhIiwiZXJyb3IiLCJsb2dpbk93bmVyIiwicGFzc3dvcmQiLCJsb2dvdXQiLCJyZW1vdmVJdGVtIiwicmVmcmVzaFRva2VuIiwidG9rZW4iLCJnZXRUZW5hbnRQcm9maWxlIiwidXBkYXRlVGVuYW50UHJvZmlsZSIsInRlbmFudEluZGV4IiwiZmluZEluZGV4IiwiY29tcGxldGVUZW5hbnRPbmJvYXJkaW5nIiwidXBsb2FkVGVuYW50RG9jdW1lbnQiLCJmaWxlIiwidXJsIiwiZ2V0QWxsVGVuYW50cyIsInBhZ2UiLCJsaW1pdCIsImZpbHRlcnMiLCJ0b3RhbCIsImxlbmd0aCIsImhhc01vcmUiLCJnZXRUZW5hbnRCeUlkIiwidXBkYXRlVGVuYW50QnlPd25lciIsImRlbGV0ZVRlbmFudCIsImluZGV4Iiwic3BsaWNlIiwiZ2V0QWxsUm9vbXMiLCJnZXRSb29tQnlJZCIsInJvb21JZCIsInJvb20iLCJyIiwiY3JlYXRlUm9vbSIsIm5ld1Jvb20iLCJEYXRlIiwibm93IiwidG9JU09TdHJpbmciLCJwdXNoIiwidXBkYXRlUm9vbSIsInJvb21JbmRleCIsImRlbGV0ZVJvb20iLCJhc3NpZ25UZW5hbnRUb1Jvb20iLCJyZW1vdmVUZW5hbnRGcm9tUm9vbSIsInVuZGVmaW5lZCIsInN1Ym1pdFBheW1lbnQiLCJuZXdQYXltZW50IiwidW5zaGlmdCIsImdldFRlbmFudFBheW1lbnRzIiwicGF5bWVudHMiLCJmaWx0ZXIiLCJwIiwiZ2V0QWxsUGF5bWVudHMiLCJ1cGRhdGVQYXltZW50U3RhdHVzIiwicGF5bWVudElkIiwicGF5bWVudEluZGV4IiwidmVyaWZ5UGF5bWVudCIsInZlcmlmaWVkIiwiY3JlYXRlU2VydmljZVJlcXVlc3QiLCJuZXdSZXF1ZXN0IiwiZ2V0VGVuYW50U2VydmljZVJlcXVlc3RzIiwicmVxdWVzdHMiLCJzciIsImdldEFsbFNlcnZpY2VSZXF1ZXN0cyIsInVwZGF0ZVNlcnZpY2VSZXF1ZXN0U3RhdHVzIiwicmVxdWVzdElkIiwicmVxdWVzdEluZGV4IiwiYWRkU2VydmljZVJlcXVlc3ROb3RlIiwibm90ZSIsInJlcXVlc3QiLCJub3RlcyIsInRleHQiLCJjcmVhdGVkQnkiLCJnZXROb3RpZmljYXRpb25zIiwibm90aWZpY2F0aW9ucyIsIm4iLCJtYXJrTm90aWZpY2F0aW9uQXNSZWFkIiwibm90aWZpY2F0aW9uSWQiLCJub3RpZmljYXRpb25JbmRleCIsIm1hcmtBbGxOb3RpZmljYXRpb25zQXNSZWFkIiwiZm9yRWFjaCIsInNlbmROb3RpZmljYXRpb24iLCJuZXdOb3RpZmljYXRpb24iLCJhY3Rpb25VcmwiLCJzZW5kQnVsa05vdGlmaWNhdGlvbnMiLCJ1c2VySWRzIiwiZ2V0RGFzaGJvYXJkU3RhdHMiLCJ0b3RhbFJvb21zIiwib2NjdXBpZWRSb29tcyIsInRvdGFsVGVuYW50cyIsInBlbmRpbmdQYXltZW50cyIsInRvdGFsUmV2ZW51ZSIsInJlZHVjZSIsInN1bSIsInBlbmRpbmdTZXJ2aWNlUmVxdWVzdHMiLCJnZXRSZXZlbnVlQW5hbHl0aWNzIiwicGVyaW9kIiwibW9udGhseURhdGEiLCJyZXZlbnVlIiwiZ2V0T2NjdXBhbmN5QW5hbHl0aWNzIiwib2NjdXBhbmN5UmF0ZSIsIm9jY3VwYW5jeSIsImdldFBheW1lbnRBbmFseXRpY3MiLCJ0b3RhbFBheW1lbnRzIiwidmVyaWZpZWRQYXltZW50cyIsImV4cG9ydERhdGEiLCJmb3JtYXQiLCJkb3dubG9hZFVybCIsInVwbG9hZEZpbGUiLCJtZXRhZGF0YSIsImRlbGV0ZUZpbGUiLCJmaWxlSWQiLCJzdWJzY3JpYmVUb1VwZGF0ZXMiLCJjYWxsYmFjayIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJNYXRoIiwicmFuZG9tIiwidXBkYXRlVHlwZXMiLCJyYW5kb21UeXBlIiwidGltZXN0YW1wIiwiY2xlYXJJbnRlcnZhbCIsIm1vY2tBcGlTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/services/mockApi.ts\n"));

/***/ })

});